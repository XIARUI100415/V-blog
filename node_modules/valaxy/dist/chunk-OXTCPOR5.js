// node/cli/index.ts
import process15 from "node:process";
import yargs from "yargs";
import { hideBin } from "yargs/helpers";

// package.json
var version = "0.23.3";

// node/modules/fuse.ts
import path4 from "node:path";
import { consola as consola9 } from "consola";
import { colors as colors7 } from "consola/utils";
import fg2 from "fast-glob";
import fs7 from "fs-extra";
import matter from "gray-matter";

// node/modules/index.ts
function defineValaxyModule(module) {
  return module;
}
function setupModules(node, modules2) {
  modules2.forEach((module) => {
    module.setup?.(node);
  });
}

// node/cli/options.ts
function commonOptions(args) {
  return args.positional("root", {
    default: ".",
    type: "string",
    describe: "root folder of your source files"
  });
}

// node/options.ts
import { dirname as dirname2 } from "node:path";
import process4 from "node:process";
import { ensureSuffix, uniq } from "@antfu/utils";
import { consola as consola7 } from "consola";
import { colors as colors6 } from "consola/utils";
import _debug from "debug";
import fg from "fast-glob";
import fs5 from "fs-extra";
import { resolve as resolve4 } from "pathe";

// node/build/bundle.ts
import path from "node:path";
var cache = /* @__PURE__ */ new Map();
var cacheTheme = /* @__PURE__ */ new Map();
function escapeRegExp(str) {
  return str.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var CSS_LANGS_RE = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
function isEagerChunk(id, getModuleInfo) {
  if (id.includes("node_modules") && !CSS_LANGS_RE.test(id) && staticImportedByEntry(id, getModuleInfo, cache)) {
    return true;
  }
}
function staticImportedByEntry(id, getModuleInfo, cache3, entryRE = null, importStack = []) {
  if (cache3.has(id)) {
    return !!cache3.get(id);
  }
  if (importStack.includes(id)) {
    cache3.set(id, false);
    return false;
  }
  const mod = getModuleInfo(id);
  if (!mod) {
    cache3.set(id, false);
    return false;
  }
  if (entryRE ? entryRE.test(id) : mod.isEntry) {
    cache3.set(id, true);
    return true;
  }
  const someImporterIs = mod.importers.some(
    (importer) => staticImportedByEntry(
      importer,
      getModuleInfo,
      cache3,
      entryRE,
      importStack.concat(id)
    )
  );
  cache3.set(id, someImporterIs);
  return someImporterIs;
}
function getRollupOptions(options) {
  const excludedModules = [
    "/@siteData",
    "node_modules/@vueuse/core/",
    "node_modules/@vueuse/shared/",
    "node_modules/vue/",
    "node_modules/vue-demi/",
    options.clientRoot
  ];
  const themeEntryRE = new RegExp(
    `^${escapeRegExp(
      path.resolve(options.themeRoot, "index.ts").replace(/\\/g, "/")
    )}`
  );
  const assetsDir = "assets";
  const rollupOptions = {
    ...options.config.vite?.build?.rollupOptions,
    external: [],
    // important so that each page chunk and the index export things for each
    // other
    preserveEntrySignatures: "allow-extension",
    output: {
      assetFileNames: `${assetsDir}/[name].[hash].[ext]`,
      entryFileNames: `${assetsDir}/[name].[hash].js`,
      chunkFileNames() {
        return `${assetsDir}/[name].[hash].js`;
      },
      manualChunks(id, ctx) {
        if (id.startsWith("\0vite")) {
          return "framework";
        }
        if (id.includes("plugin-vue:export-helper")) {
          return "framework";
        }
        const libs = [
          "@vueuse/motion",
          "dayjs",
          "vue-i18n",
          "vue-router",
          "nprogress",
          "pinia"
        ];
        for (const lib of libs) {
          if (id.includes(lib)) {
            return `chunks/${lib}`;
          }
        }
        if (isEagerChunk(id, ctx.getModuleInfo) && /@vue\/(runtime|shared|reactivity)/.test(id)) {
          return "framework";
        }
        if ((id.startsWith(options.themeRoot) || !excludedModules.some((i) => id.includes(i))) && staticImportedByEntry(
          id,
          ctx.getModuleInfo,
          cacheTheme,
          themeEntryRE
        )) {
          return "theme";
        }
      }
    }
  };
  return rollupOptions;
}

// node/config/addon.ts
import path2 from "node:path";
import fs2 from "fs-extra";

// node/config/valaxy.ts
import process2 from "node:process";
import { isFunction } from "@antfu/utils";
import { consola as consola4 } from "consola";
import { colors as colors2 } from "consola/utils";
import { createDefu } from "defu";
import { mergeConfig as mergeViteConfig } from "vite";

// node/utils/performance.ts
import { consola } from "consola";
function countPerformanceTime() {
  const start = performance.now();
  return () => {
    const end = performance.now();
    const duration = end - start;
    if (duration > 1e3)
      return `${(duration / 1e3).toFixed(2)}s`;
    return `${duration.toFixed(2)}ms`;
  };
}

// node/config/site.ts
import { webcrypto } from "node:crypto";
import { consola as consola3 } from "consola";
import { colors } from "consola/utils";
import { options as floatingVueOptions } from "floating-vue";

// node/config/utils.ts
import process from "node:process";
import { consola as consola2 } from "consola";
import fs from "fs-extra";
import { createJiti } from "jiti";
import { resolve } from "pathe";
var jiti = createJiti(import.meta.url, {
  // for hmr
  moduleCache: false
});
async function loadConfig(options) {
  const { name, cwd } = options;
  const filePath = resolve(cwd, `${name}.config.ts`);
  let data = {};
  if (await fs.exists(filePath)) {
    try {
      data = await jiti.import(filePath, { default: true });
    } catch (e) {
      console.error(e);
      consola2.error(`Failed to load config file: ${filePath}`);
    }
  } else {
    consola2.debug(`Config file not found: ${filePath}`);
  }
  return {
    config: data,
    configFile: filePath
  };
}
async function loadConfigFromFile(file, options = {}) {
  const { config, configFile } = await loadConfig({
    name: file,
    cwd: options.cwd || process.cwd()
  });
  let userConfig = config;
  if (typeof config === "function")
    userConfig = await config(options.valaxyOptions || {});
  return {
    config: userConfig,
    configFile
  };
}

// node/config/site.ts
var defaultSiteConfig = {
  mode: "auto",
  url: "/",
  lang: "en",
  languages: ["en", "zh-CN"],
  timezone: "",
  title: "Valaxy Blog",
  description: "A blog generated by Valaxy.",
  subtitle: "Next Generation Static Blog Framework.",
  author: {
    avatar: "https://valaxy.site/valaxy-logo.png",
    email: "i@valaxy.site",
    link: "https://valaxy.site",
    name: "VALAXY Developer",
    status: {
      emoji: "\u{1F30C}",
      message: "The moonlight is beautiful."
    }
  },
  favicon: "/favicon.svg",
  feed: {
    name: "",
    favicon: "/favicon.svg"
  },
  social: [],
  lastUpdated: true,
  license: {
    enabled: true,
    language: "",
    type: "by-nc-sa"
  },
  sponsor: {
    enable: true,
    description: "\u8FD9\u662F\u5173\u4E8E\u8D5E\u52A9\u7684\u4E00\u4E9B\u63CF\u8FF0",
    methods: []
  },
  search: {
    enable: false,
    type: "fuse"
  },
  fuse: {
    dataPath: "valaxy-fuse-list.json",
    options: {
      keys: []
    }
  },
  comment: {
    enable: false
  },
  frontmatter: {
    time_warning: 180 * 24 * 60 * 60 * 1e3
  },
  cdn: {
    prefix: "https://unpkg.com/"
  },
  mediumZoom: {
    enable: false,
    selector: "",
    options: {}
  },
  vanillaLazyload: {
    enable: false,
    options: {}
  },
  floatingVue: floatingVueOptions,
  statistics: {
    enable: false,
    readTime: {
      speed: {
        cn: 300,
        en: 100
      }
    }
  },
  pageSize: 7,
  encrypt: {
    enable: false,
    algorithm: "AES-CBC",
    salt: webcrypto.getRandomValues(new Uint8Array(16)),
    iv: webcrypto.getRandomValues(new Uint8Array(16))
  },
  redirects: {
    useVueRouter: true,
    rules: []
  }
};
function defineSiteConfig(config) {
  return config;
}
async function resolveSiteConfigFromRoot(root) {
  return loadConfigFromFile("site", {
    cwd: root
  });
}
async function resolveSiteConfig(root) {
  const endCount = countPerformanceTime();
  const { config: userSiteConfig, configFile: siteConfigFile } = await resolveSiteConfigFromRoot(root);
  const duration = endCount();
  if (userSiteConfig && siteConfigFile)
    consola3.success(`Resolve ${colors.cyan("siteConfig")} from ${colors.dim(siteConfigFile)} ${colors.yellow(duration)}`);
  return {
    siteConfig: userSiteConfig,
    siteConfigFile
  };
}

// node/config/valaxy.ts
var defaultValaxyConfig = {
  siteConfig: defaultSiteConfig,
  theme: "yun",
  themeConfig: {
    pkg: {
      name: "",
      version: ""
    }
  },
  build: {
    ssgForPagination: false
  },
  deploy: {},
  // markdown: {
  //   excerpt: '<!-- more -->',
  // },
  runtimeConfig: {
    addons: {},
    redirects: {
      useVueRouter: true,
      redirectRoutes: []
    }
  },
  modules: {
    rss: {
      enable: true,
      fullText: false
    }
  },
  features: {
    katex: true
  },
  vite: {
    build: {
      emptyOutDir: true
      // cssCodeSplit: false,
    }
  },
  devtools: true
};
function defineValaxyConfig(config) {
  return config;
}
var defineConfig = defineValaxyConfig;
async function resolveValaxyConfigFromRoot(root, options) {
  const c = await loadConfigFromFile("valaxy", {
    cwd: root,
    valaxyOptions: options
  });
  return c;
}
var mergeValaxyConfig = createDefu((obj, key, value) => {
  if (isFunction(obj[key]) && isFunction(value)) {
    obj[key] = function(...args) {
      obj[key].call(this, ...args);
      value.call(this, ...args);
    };
  }
  if (key === "vite") {
    obj[key] = mergeViteConfig(obj[key], value);
    return true;
  }
});
async function resolveValaxyConfig(options) {
  const configRoot = options.userRoot || process2.cwd();
  const endCount = countPerformanceTime();
  const { config: userValaxyConfig, configFile } = await resolveValaxyConfigFromRoot(configRoot);
  const duration = endCount();
  if (configFile && userValaxyConfig && Object.keys(userValaxyConfig).length !== 0)
    consola4.success(`Resolve ${colors2.cyan("userValaxyConfig")} from ${colors2.dim(configFile)} ${colors2.yellow(duration)}`);
  const theme = options.theme || userValaxyConfig?.theme || "yun";
  return {
    config: userValaxyConfig,
    configFile,
    theme
  };
}

// node/config/addon.ts
function defineValaxyAddon(addonFunc) {
  return addonFunc;
}
var defineAddon = defineValaxyAddon;
async function resolveAddonsConfig(addons, options) {
  let valaxyConfig = {};
  for (const addon of addons) {
    const addonConfigPath = path2.resolve(addon.root, "valaxy.config.ts");
    if (!await fs2.exists(addonConfigPath))
      continue;
    const { config, configFile } = await resolveValaxyConfigFromRoot(addon.root, options);
    if (!config)
      continue;
    addon.configFile = configFile;
    valaxyConfig = mergeValaxyConfig(config, valaxyConfig);
  }
  return valaxyConfig;
}

// node/config/theme.ts
import { colors as colors4 } from "consola/utils";
import defu from "defu";

// node/logger/index.ts
import { consola as consola5 } from "consola";
import { colors as colors3 } from "consola/utils";
import ora from "ora";
var logger = consola5.create({});
var valaxyPrefix = colors3.magenta("[valaxy]");
var vLogger = {
  success: (...args) => logger.success(valaxyPrefix, ...args),
  info: (...args) => logger.info(valaxyPrefix, ...args),
  ready: (...args) => logger.ready(valaxyPrefix, ...args)
};
async function callHookWithLog(hookName, valaxyApp) {
  const hookNameStr = `${colors3.cyan("[HOOK]")} ${colors3.magenta(hookName)}`;
  const s = ora(`${hookNameStr} calling...`).start();
  await valaxyApp.hooks.callHook(hookName);
  s.succeed(`${hookNameStr} done.`);
}

// node/config/theme.ts
async function resolveThemeConfigFromRoot(root) {
  return loadConfigFromFile("theme", {
    cwd: root
  });
}
async function resolveUserThemeConfig(options) {
  let { config: userThemeConfig, configFile: themeConfigFile } = await resolveThemeConfigFromRoot(options.userRoot);
  if (userThemeConfig && themeConfigFile)
    logger.info(`Resolve ${colors4.cyan("themeConfig")} from ${colors4.dim(themeConfigFile)}`);
  if (options?.themeRoot) {
    const { config: defaultThemeConfig } = await resolveThemeConfigFromRoot(options.themeRoot);
    userThemeConfig = defu(userThemeConfig || {}, defaultThemeConfig);
  }
  return {
    themeConfig: userThemeConfig,
    themeConfigFile
  };
}
function defineValaxyTheme(theme) {
  return theme;
}
var defineTheme = defineValaxyTheme;

// node/config/index.ts
function defineUnoSetup(fn) {
  return fn;
}

// node/config/merge.ts
import { createDefu as createDefu2 } from "defu";
var replaceArrMerge = createDefu2((obj, key, value) => {
  if (key && obj[key] && Array.isArray(obj[key]) && Array.isArray(value)) {
    obj[key] = value;
    return true;
  }
});

// node/utils/getGitTimestamp.ts
import { spawn } from "cross-spawn";
function getGitTimestamp(file, type = "updated") {
  return new Promise((resolve15, _reject) => {
    const params = ["log"];
    if (type === "updated")
      params.push("-1");
    params.push('--pretty="%ci"', file);
    if (type === "created")
      params.push("|", "tail", "-1");
    const child = spawn("git", params);
    let output = "";
    child.stdout.on("data", (d) => output += String(d));
    child.on("close", () => {
      resolve15(+new Date(output));
    });
    child.on("error", () => {
      resolve15(0);
    });
  });
}

// node/constants/index.ts
var EXCERPT_SEPARATOR = "<!-- more -->";
var EXTERNAL_URL_RE = /^https?:/i;
var PATHNAME_PROTOCOL_RE = /^pathname:\/\//;
var ALL_ROUTE = "/:all(.*)*";
var customElements = /* @__PURE__ */ new Set([
  // katex
  "annotation",
  "math",
  "menclose",
  "mfrac",
  "mglyph",
  "mi",
  "mlabeledtr",
  "mn",
  "mo",
  "mover",
  "mpadded",
  "mphantom",
  "mroot",
  "mrow",
  "mspace",
  "msqrt",
  "mstyle",
  "msub",
  "msubsup",
  "msup",
  "mtable",
  "mtd",
  "mtext",
  "mtr",
  "munder",
  "munderover",
  "semantics"
]);
var defaultViteConfig = {
  css: {
    preprocessorOptions: {
      scss: {
        api: "modern-compiler"
      }
    }
  }
};

// node/utils/helper.ts
function isExternal(str) {
  return EXTERNAL_URL_RE.test(str);
}
function isPath(name) {
  return name.startsWith("/") || /^\.\.?[/\\]/.test(name);
}
function transformObject(obj) {
  return `JSON.parse(${JSON.stringify(JSON.stringify(obj))})`;
}

// node/utils/resolve.ts
import { ensurePrefix, slash } from "@antfu/utils";
import { consola as consola6 } from "consola";
import { resolvePath } from "mlly";
import { resolveGlobal } from "resolve-global";
var isInstalledGlobally = {};
async function resolveImportUrl(id) {
  return toAtFS(await resolveImportPath(id, true));
}
function toAtFS(path17) {
  return `/@fs${ensurePrefix("/", slash(path17))}`;
}
async function resolveImportPath(importName, ensure = false) {
  try {
    return await resolvePath(importName, {
      url: import.meta.url
    });
  } catch (error) {
    consola6.log(error);
  }
  if (isInstalledGlobally.value) {
    try {
      return resolveGlobal(importName);
    } catch {
    }
  }
  if (ensure)
    throw new Error(`Failed to resolve package ${importName}`);
  else
    consola6.warn(`Failed to resolve package ${importName}`);
}

// node/utils/addons.ts
import process3 from "node:process";
import { colors as colors5 } from "consola/utils";
import defu2 from "defu";
import fs4 from "fs-extra";
import ora2 from "ora";
import { resolve as resolve3 } from "pathe";

// node/utils/root.ts
import { dirname } from "node:path";
import fs3 from "fs-extra";
import { resolve as resolve2 } from "pathe";
async function getModuleRoot(name, entry) {
  if (!name)
    return "";
  if (isPath(name)) {
    if (entry) {
      const isFile = fs3.lstatSync(entry).isFile();
      return resolve2(isFile ? dirname(entry) : entry, name);
    } else {
      throw new Error(`entry is required when ${name} is path`);
    }
  } else {
    return resolve2(dirname(await resolveImportPath(`${name}/package.json`) || ""));
  }
}

// node/utils/addons.ts
async function parseAddons(addons, userRoot2 = process3.cwd()) {
  const spinner = ora2(`Resolve ${colors5.cyan("addons")} from ${colors5.dim(userRoot2)}`).start();
  const resolvers = {};
  const mergeResolver = (resolver) => {
    if (resolver)
      resolvers[resolver.name] = defu2(resolvers[resolver.name] || {}, resolver);
  };
  if (Array.isArray(addons)) {
    for (const addon of addons) {
      if (typeof addon === "string") {
        mergeResolver(await readAddonModule(addon, { cwd: userRoot2 }));
        continue;
      }
      if (typeof addon === "object")
        mergeResolver(defu2(await readAddonModule(addon.name, { cwd: userRoot2 }), addon || {}));
    }
  }
  spinner.succeed();
  const resolvedAddons = Object.values(resolvers).filter((item) => item.enable);
  resolvedAddons.forEach((addon, i) => {
    console.log(`  ${i === resolvedAddons.length - 1 ? "\u2514\u2500" : "\u251C\u2500"} ${colors5.yellow(addon.name)} ${colors5.blue(`v${addon.pkg?.version}`)}${addon.global ? colors5.cyan(" (global)") : ""} ${colors5.dim(addon.pkg.homepage || addon.pkg.repository?.url || addon.pkg.repository || "")}`);
  });
  return resolvedAddons;
}
async function readAddonModule(name, options = {}) {
  const root = await getAddonRoot(name, options.cwd || process3.cwd());
  const packageJSONPath = resolve3(root, "./package.json");
  if (!await fs4.exists(packageJSONPath)) {
    logger.error(`No addon named ${name} found`);
    return;
  }
  const packageJSON = await fs4.readJSON(packageJSONPath);
  const resolver = {
    enable: true,
    name: packageJSON.name,
    global: !!packageJSON.global,
    root,
    options: {},
    props: {},
    pkg: packageJSON
  };
  return resolver;
}
async function getAddonRoot(name, entry) {
  const addonModule = name.startsWith("valaxy-addon") || name.startsWith(".") ? name : `valaxy-addon-${name}`;
  return await getModuleRoot(addonModule, entry);
}

// node/utils/clientRedirects.ts
import { writeFile } from "node:fs/promises";
import { ensureFile } from "fs-extra";
function handleRoute(route) {
  if (route === "/")
    return "/index";
  if (route.endsWith("/"))
    return route.slice(0, -1);
  return route;
}
function collectRedirects(redirectRules) {
  if (!redirectRules)
    return [];
  const redirects = [];
  for (const rule of redirectRules) {
    if (Array.isArray(rule.from)) {
      for (const from of rule.from) {
        redirects.push({
          from: handleRoute(from),
          to: handleRoute(rule.to)
        });
      }
    } else {
      redirects.push({
        from: handleRoute(rule.from),
        to: handleRoute(rule.to)
      });
    }
  }
  return redirects;
}
async function writeRedirectFiles(route, filePath) {
  await ensureFile(filePath);
  await writeFile(filePath, `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="refresh" content="0; url=${route}">
  <link rel="canonical" href="${route}">
</head>
  <script>
    window.location.href = '${route}' + window.location.search + window.location.hash
  </script>
</html>
  `);
}

// node/utils/theme.ts
async function getThemeRoot(name, entry) {
  const themeModule = name.startsWith("valaxy-theme") || name.startsWith(".") ? name : `valaxy-theme-${name}`;
  return await getModuleRoot(themeModule, entry);
}

// node/options.ts
var debug = _debug("valaxy:options");
async function processSiteConfig(options) {
  const { config, themeRoot, theme } = options;
  const siteConfig = config.siteConfig;
  siteConfig.url = ensureSuffix("/", siteConfig.url || "");
  siteConfig.cdn.prefix = ensureSuffix("/", siteConfig.cdn.prefix || "");
  const themePkgPath = resolve4(themeRoot, "package.json");
  try {
    config.themeConfig.pkg = await fs5.readJson(themePkgPath, "utf-8");
  } catch (e) {
    console.error(`valaxy-theme-${theme} doesn't have package.json`);
  }
}
async function processValaxyOptions(valaxyOptions, valaxyConfig) {
  const { clientRoot, themeRoot, userRoot: userRoot2 } = valaxyOptions;
  const addons = await parseAddons(valaxyConfig.addons || [], valaxyOptions.userRoot);
  const addonsValaxyConfig = await resolveAddonsConfig(addons, valaxyOptions);
  valaxyConfig = mergeValaxyConfig(valaxyConfig, addonsValaxyConfig);
  const rollupOptions = getRollupOptions(valaxyOptions);
  defaultValaxyConfig.vite.build.rollupOptions = rollupOptions;
  const config = replaceArrMerge(valaxyConfig, defaultValaxyConfig);
  valaxyOptions.config = {
    ...config,
    runtimeConfig: {
      addons: {},
      redirects: {
        useVueRouter: true,
        redirectRoutes: []
      }
    }
  };
  valaxyOptions.addons = addons;
  addons.forEach((addon) => {
    valaxyOptions.config.runtimeConfig.addons[addon.name] = addon;
  });
  const addonRoots = addons.map(({ root }) => root);
  const addonNames = addons.map(({ name }) => name);
  valaxyOptions.addonRoots = addonRoots;
  valaxyOptions.roots = uniq([clientRoot, themeRoot, ...addonRoots, userRoot2]);
  const external = valaxyOptions.config.vite?.build?.rollupOptions?.external || [];
  valaxyOptions.config.vite.build.rollupOptions.external = external.filter((name) => !addonNames.includes(name));
  await processSiteConfig(valaxyOptions);
  return valaxyOptions;
}
async function resolveOptions(options = { userRoot: process4.cwd() }, mode = "dev") {
  const pkgRoot = dirname2(await resolveImportPath("valaxy/package.json", true));
  const clientRoot = resolve4(pkgRoot, "client");
  const userRoot2 = resolve4(options.userRoot || process4.cwd());
  consola7.start(`Resolve ${colors6.magenta("valaxy")} config ...`);
  const [resolvedValaxy, resolvedSite, resolvedTheme, pages] = await Promise.all([
    resolveValaxyConfig(options),
    resolveSiteConfig(options.userRoot),
    // resolveThemeConfig(options),
    resolveThemeConfigFromRoot(options.userRoot),
    fg(["**.md"], {
      cwd: resolve4(userRoot2, "pages"),
      ignore: ["**/node_modules"]
    })
  ]);
  let { config: userValaxyConfig, configFile, theme } = resolvedValaxy;
  const themeRoot = await getThemeRoot(theme, options.userRoot);
  const { siteConfig, siteConfigFile } = resolvedSite;
  const { config: themeConfig, configFile: themeConfigFile } = resolvedTheme;
  const redirects = collectRedirects(siteConfig.redirects?.rules);
  userValaxyConfig = replaceArrMerge({ siteConfig }, { themeConfig }, userValaxyConfig);
  let valaxyOptions = {
    mode,
    pkgRoot,
    tempDir: resolve4(userRoot2, ".valaxy"),
    clientRoot,
    userRoot: userRoot2,
    themeRoot,
    addonRoots: [],
    roots: [],
    theme,
    config: {
      ...userValaxyConfig,
      runtimeConfig: {
        addons: {},
        redirects: {
          useVueRouter: true,
          redirectRoutes: []
        }
      }
    },
    configFile: configFile || "",
    siteConfigFile: siteConfigFile || "",
    themeConfigFile: themeConfigFile || "",
    pages: pages.sort(),
    addons: [],
    redirects,
    env: {
      id: "",
      links: []
    }
  };
  debug(valaxyOptions);
  const themeValaxyConfig = await resolveThemeValaxyConfig(valaxyOptions);
  const valaxyConfig = mergeValaxyConfig(userValaxyConfig, themeValaxyConfig);
  valaxyOptions = await processValaxyOptions(valaxyOptions, valaxyConfig);
  fs5.ensureDirSync(valaxyOptions.tempDir);
  return valaxyOptions;
}
async function resolveThemeValaxyConfig(options) {
  const endCount = countPerformanceTime();
  const { config: themeValaxyConfig } = await resolveValaxyConfigFromRoot(options.themeRoot, options);
  const duration = endCount();
  if (themeValaxyConfig)
    consola7.success(`Resolve ${colors6.cyan("valaxy.config.ts")} from ${colors6.blue(`theme(${options.theme})`)} ${colors6.yellow(duration)}`);
  return themeValaxyConfig;
}

// node/plugins/markdown/transform/matter.ts
import yaml, { CORE_SCHEMA } from "js-yaml";
var matterOptions = {
  excerpt_separator: EXCERPT_SEPARATOR,
  engines: {
    yaml: {
      // Use the CORE_SCHEMA with more basic support to manually handle time (#409)
      parse: (str) => yaml.load(str, { schema: CORE_SCHEMA }),
      stringify: (data) => yaml.dump(data)
    }
  }
};

// node/utils/env.ts
import path3 from "node:path";
import process5 from "node:process";
import { consola as consola8 } from "consola";
import fs6 from "fs-extra";
function isProd() {
  return process5.env.NODE_ENV === "production";
}
function setEnv(env = "development") {
  process5.env.NODE_ENV = env;
  consola8.level = isProd() ? 2 : 3;
  logger.level = consola8.level;
}
function setEnvProd() {
  return setEnv("production");
}
function setTimezone(timezone) {
  process5.env.TZ = timezone;
}
async function isPagesDirExist(root) {
  const exist = await fs6.exists(path3.resolve(root, "pages"));
  if (!exist)
    logger.error(`No pages directory found in ${root}`);
  return exist;
}

// node/modules/fuse.ts
async function generateFuseList(options) {
  consola9.start(`Generate List for Fuse Search by (${colors7.cyan("fuse.js")}) ...`);
  const files = await fg2(`${options.userRoot}/pages/posts/**/*.md`);
  const posts = [];
  for await (const i of files) {
    const raw = fs7.readFileSync(i, "utf-8");
    const { data, excerpt, content } = matter(raw, matterOptions);
    const fmData = data;
    if (fmData.draft) {
      consola9.warn(`Ignore draft post: ${colors7.dim(i)}`);
      continue;
    }
    if (fmData.hide)
      continue;
    if (fmData.password)
      continue;
    const extendKeys = options.config.fuse?.extendKeys || [];
    const relativeLink = i.replace(`${options.userRoot}/pages`, "");
    const link = i.endsWith("index.md") ? relativeLink.replace(/\/index\.md$/, "") : relativeLink.replace(/\.md$/, "");
    const fuseListItem = {
      title: fmData.title || "",
      tags: (typeof fmData.tags === "string" ? [fmData.tags] : fmData.tags) || [],
      categories: (typeof fmData.categories === "string" ? [fmData.categories] : fmData.categories) || [],
      author: options.config.siteConfig.author.name,
      excerpt: excerpt || content.slice(0, 100),
      // encode for chinese url
      link: encodeURI(link)
    };
    if (options.config.siteConfig.fuse.options.keys?.includes("content")) {
      fuseListItem.content = content;
    }
    extendKeys.forEach((key) => {
      fuseListItem[key] = fmData[key] || "";
    });
    posts.push(fuseListItem);
  }
  return posts;
}
async function execFuse(options) {
  consola9.info("Start generate fuse list...");
  const fuseList = await generateFuseList(options);
  await fs7.ensureDir("./dist");
  const publicFolder = path4.resolve(options.userRoot, "public");
  const publicFuseFile = path4.resolve(publicFolder, options.config.siteConfig.fuse.dataPath);
  const publicRelativeFile = path4.join("public", options.config.siteConfig.fuse.dataPath);
  await fs7.ensureFile(publicFuseFile);
  fs7.writeJSONSync(publicFuseFile, fuseList);
  consola9.success(`Generate fuse list in ${colors7.dim(publicFolder)}`);
  const distFolder = path4.resolve(options.userRoot, "dist");
  const distFuseFile = path4.resolve(distFolder, options.config.siteConfig.fuse.dataPath);
  await fs7.ensureDir(distFolder);
  fs7.writeJSONSync(distFuseFile, fuseList);
  consola9.success(`Generate fuse list in ${colors7.dim(distFolder)}`);
  try {
    const gitignorePath = path4.resolve(options.userRoot, ".gitignore");
    const gitignore = await fs7.readFile(gitignorePath, "utf-8");
    const ignorePath = publicRelativeFile.replace(/\\/g, "/");
    if (!gitignore.includes(ignorePath)) {
      await fs7.appendFile(gitignorePath, `
# valaxy fuse
${ignorePath}
`);
      consola9.success(`Add ${colors7.dim(ignorePath)} to ${colors7.dim(".gitignore")}`);
    }
  } catch {
  }
}
function registerFuseCommand(cli2) {
  cli2.command(
    "fuse [root]",
    "generate fuse list for search",
    (args) => commonOptions(args).strict().help(),
    async ({ root }) => {
      setEnvProd();
      const options = await resolveOptions({ userRoot: root }, "build");
      await execFuse(options);
    }
  );
}
var fuseModule = defineValaxyModule({
  extendCli(cli2) {
    registerFuseCommand(cli2);
  },
  setup(node) {
    node.hook("build:before", async () => {
      await execFuse(node.options);
    });
  }
});

// node/modules/rss/utils.ts
import { readFile } from "node:fs/promises";
import { dirname as dirname3, join, resolve as resolve5 } from "node:path";
import { ensurePrefix as ensurePrefix2 } from "@antfu/utils";
import { consola as consola10 } from "consola";
import { colors as colors8 } from "consola/utils";
import dayjs from "dayjs";
import fg3 from "fast-glob";
import { Feed } from "feed";
import fs9 from "fs-extra";
import matter2 from "gray-matter";
import MarkdownIt from "markdown-it";
import ora3 from "ora";
import { getBorderCharacters, table } from "table";

// node/utils/date.ts
import fs8 from "fs-extra";
async function getCreatedTime(file) {
  return await getGitTimestamp(file, "created") || (await fs8.stat(file)).ctime;
}
async function getUpdatedTime(file) {
  return await getGitTimestamp(file, "created") || (await fs8.stat(file)).mtime;
}

// node/modules/rss/utils.ts
var markdown = MarkdownIt({
  html: true,
  breaks: true,
  linkify: true
});
async function build(options) {
  const s = ora3("RSS Generating ...").start();
  const { config } = options;
  const siteConfig = config.siteConfig;
  if (!siteConfig.url || siteConfig.url === "/") {
    consola10.error("You must set `url` (like `https://example.com`) in `site.config.ts` to generate rss.");
    return;
  }
  const siteUrl = siteConfig.url;
  const author = {
    name: siteConfig.author?.name,
    email: siteConfig.author?.email,
    link: siteConfig.author?.link
  };
  const ccVersion = siteConfig.license?.type === "zero" ? "1.0" : "4.0";
  const feedNameMap = {
    atom: siteConfig.feed?.name ? `${siteConfig.feed?.name}.atom` : "atom.xml",
    json: `${siteConfig.feed?.name || "feed"}.json`,
    rss: `${siteConfig.feed?.name || "feed"}.xml`
  };
  const feedOptions = {
    title: siteConfig.title || "Valaxy Blog",
    description: siteConfig.description,
    id: siteUrl || "valaxy",
    link: siteUrl,
    copyright: `CC ${siteConfig.license?.type?.toUpperCase()} ${ccVersion} ${(/* @__PURE__ */ new Date()).getFullYear()} \xA9 ${siteConfig.author?.name}`,
    feedLinks: {}
  };
  Object.keys(feedNameMap).forEach((key) => {
    feedOptions.feedLinks[key] = `${siteUrl}${feedNameMap[key]}`;
  });
  const DOMAIN = siteConfig.url.slice(0, -1);
  const files = await fg3(`${options.userRoot}/pages/posts/**/*.md`);
  const posts = await getPosts({
    author,
    files,
    DOMAIN
  }, options);
  if (!posts)
    return;
  const authorAvatar = siteConfig.author?.avatar || "/favicon.svg";
  feedOptions.author = author;
  feedOptions.image = isExternal(authorAvatar) ? siteConfig.author?.avatar : `${DOMAIN}${ensurePrefix2("/", authorAvatar)}`;
  feedOptions.favicon = `${DOMAIN}${siteConfig.feed?.favicon || siteConfig.favicon}`;
  s.succeed("RSS Generated.");
  await writeFeed(feedOptions, posts, options, feedNameMap);
}
async function getPosts(params, options) {
  const { config } = options;
  const siteConfig = config.siteConfig;
  const lang = siteConfig.lang || "en";
  const { files, author, DOMAIN } = params;
  const readFilePromises = files.map(async (i) => {
    const raw = await readFile(i, "utf-8");
    const { data, content, excerpt } = matter2(raw, matterOptions);
    return { data, content, excerpt, path: i };
  });
  const draftPosts = [];
  const rawPosts = await Promise.all(readFilePromises);
  const filteredPosts = rawPosts.filter((p) => {
    const { data } = p;
    if (data.password)
      return false;
    if (data.draft) {
      draftPosts.push(p);
      return false;
    }
    if (data.hide)
      return false;
    return true;
  });
  const posts = [];
  for (const rawPost of filteredPosts) {
    const { data, path: path17, content, excerpt } = rawPost;
    if (!data.date)
      data.date = await getCreatedTime(path17);
    if (siteConfig.lastUpdated) {
      if (!data.updated)
        data.updated = await getUpdatedTime(path17);
    }
    const fullText = options.config.modules.rss.fullText;
    const rssContent = fullText ? content : excerpt || content.slice(0, 100);
    const html = markdown.render(rssContent).replace('src="/', `src="${DOMAIN}/`);
    if (data.image?.startsWith("/"))
      data.image = DOMAIN + data.image;
    const link = DOMAIN + path17.replace(`${options.userRoot}/pages`, "").replace(/\.md$/, "");
    const tip = `<br/><p>${lang === "zh-CN" ? `\u8BBF\u95EE <a href="${link}" target="_blank">${link}</a> ${fullText ? "\u67E5\u770B\u539F\u6587" : "\u9605\u8BFB\u5168\u6587"}\u3002` : `Visit <a href="${link}" target="_blank">${link}</a> to ${fullText ? "view original article" : "read more"}.`}</p>`;
    posts.push({
      title: "",
      ...data,
      date: new Date(data.date),
      published: new Date(data.updated || data.date),
      content: html + tip,
      author: [author],
      id: data.id?.toString() || "",
      link
    });
  }
  posts.sort((a, b) => +new Date(b.published || b.date) - +new Date(a.published || a.date));
  return posts;
}
async function writeFeed(feedOptions, posts, options, feedNameMap) {
  const feed = new Feed(feedOptions);
  posts.forEach((item) => feed.addItem(item));
  await fs9.ensureDir(dirname3(`./dist/${feedNameMap.atom}`));
  const path17 = resolve5(options.userRoot, "./dist");
  const publicFolder = resolve5(options.userRoot, "public");
  const { config } = options;
  const siteConfig = config.siteConfig;
  const now = dayjs().format("YYYY-MM-DD HH:mm:ss zzz");
  const tableData = [
    [`${colors8.yellow("RSS Feed Files")} \u{1F4E1} ${colors8.dim(now)}`, "", ""],
    [colors8.bold("Site Url"), "", colors8.cyan(siteConfig.url)],
    ["Type", "Folder", "Path"]
  ];
  const types = ["rss", "atom", "json"];
  for (const type of types) {
    let data = "";
    const distFeedPath = `${path17}/${feedNameMap[type]}`;
    if (type === "rss")
      data = feed.rss2();
    else if (type === "atom")
      data = feed.atom1();
    else if (type === "json")
      data = feed.json1();
    await fs9.writeFile(distFeedPath, data, "utf-8");
    consola10.debug(`[${colors8.cyan(type)}] dist: ${colors8.dim(distFeedPath)}`);
    tableData.push([colors8.cyan(type), colors8.yellow("dist"), colors8.dim(distFeedPath)]);
    const publicFeedPath = resolve5(publicFolder, feedNameMap[type]);
    const publicRelativeFile = join("public", feedNameMap[type]);
    await fs9.writeFile(publicFeedPath, data, "utf-8");
    consola10.debug(`[${colors8.cyan(type)}] public: ${colors8.dim(publicFeedPath)}`);
    tableData.push(["", colors8.green("public"), colors8.dim(publicFeedPath)]);
    try {
      const gitignorePath = resolve5(options.userRoot, ".gitignore");
      const gitignore = await fs9.readFile(gitignorePath, "utf-8");
      const ignorePath = publicRelativeFile.replace(/\\/g, "/");
      if (!gitignore.includes(ignorePath)) {
        await fs9.appendFile(gitignorePath, `
# valaxy rss
${ignorePath}
`);
        consola10.success(`Add ${colors8.dim(ignorePath)} to ${colors8.dim(".gitignore")}`);
      }
    } catch {
    }
  }
  console.log(table(tableData, {
    columns: [
      { alignment: "center" },
      { alignment: "right" },
      { alignment: "left" }
    ],
    spanningCells: [
      { col: 0, row: 0, colSpan: 3 },
      { col: 0, row: 1, colSpan: 2 },
      { col: 0, row: 3, rowSpan: 2, verticalAlignment: "middle" },
      { col: 0, row: 5, rowSpan: 2, verticalAlignment: "middle" },
      { col: 0, row: 7, rowSpan: 2, verticalAlignment: "middle" }
    ],
    border: getBorderCharacters("norc")
  }));
}

// node/modules/rss/index.ts
var rssModule = defineValaxyModule({
  /**
   * valaxy rss
   * @param cli
   */
  extendCli(cli2) {
    cli2.command(
      "rss [root]",
      "generate rss feed",
      (args) => commonOptions(args).strict().help(),
      async ({ root }) => {
        setEnvProd();
        const options = await resolveOptions({ userRoot: root }, "build");
        await build(options);
      }
    );
  },
  setup(node) {
    node.hook("build:after", async () => {
      console.log();
      await build(node.options);
    });
  }
});

// node/cli/build.ts
import path13 from "node:path";
import process9 from "node:process";
import { consola as consola16 } from "consola";
import { colors as colors15 } from "consola/utils";
import { mergeConfig as mergeConfig4 } from "vite";

// node/build.ts
import { join as join8, resolve as resolve13 } from "node:path";
import { consola as consola14 } from "consola";
import { colors as colors12 } from "consola/utils";
import fs21 from "fs-extra";
import { mergeConfig as mergeViteConfig2, build as viteBuild } from "vite";
import generateSitemap from "vite-ssg-sitemap";
import { build as viteSsgBuild } from "vite-ssg/node";

// node/plugins/preset.ts
import VueI18n from "@intlify/unplugin-vue-i18n/vite";
import UnheadVite from "@unhead/addons/vite";
import { consola as consola13 } from "consola";
import { resolve as resolve12 } from "pathe";
import Components from "unplugin-vue-components/vite";
import Layouts from "vite-plugin-vue-layouts";

// node/plugins/extendConfig.ts
import { dirname as dirname4, join as join3, resolve as resolve6 } from "node:path";
import { uniq as uniq3 } from "@antfu/utils";
import { mergeConfig as mergeConfig2, searchForWorkspaceRoot } from "vite";

// node/common.ts
import { join as join2 } from "node:path";
import { uniq as uniq2 } from "@antfu/utils";
import fs10 from "fs-extra";
import { loadConfigFromFile as loadConfigFromFile2, mergeConfig } from "vite";
async function mergeViteConfigs({ userRoot: userRoot2, themeRoot }, command) {
  const configEnv = {
    mode: "development",
    command
  };
  let resolvedConfig = {};
  const files = uniq2([themeRoot, userRoot2]).map((i) => join2(i, "vite.config.ts"));
  const loadViteConfigPromiseArr = files.map(async (file) => {
    if (!await fs10.exists(file))
      return;
    return loadConfigFromFile2(configEnv, file);
  });
  const viteConfigs = await Promise.all(loadViteConfigPromiseArr);
  for (const viteConfig of viteConfigs) {
    if (!viteConfig?.config)
      continue;
    resolvedConfig = mergeConfig(resolvedConfig, viteConfig.config);
  }
  return resolvedConfig;
}
async function getIndexHtml({ clientRoot, themeRoot, userRoot: userRoot2, config }, rawHtml) {
  let main = rawHtml;
  let head = "";
  let body = "";
  if (config.siteConfig.favicon)
    head += `<link rel="icon" href="${config.siteConfig.favicon}">`;
  const roots = [userRoot2, themeRoot];
  if (config.siteConfig.mode === "auto") {
    head += `
    <script>
    ;(function () {
      const prefersDark =
        window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches
      const setting = localStorage.getItem('vueuse-color-scheme') || 'auto'
      if (setting === 'dark' || (prefersDark && setting !== 'light'))
        document.documentElement.classList.toggle('dark', true)
    })()
    </script>
  `;
    head += `<style type="text/css">
    :root { color-scheme: light dark; --va-c-bg: #fff; }
    html.dark { --va-c-bg: #000; }
    html { background-color: var(--va-c-bg); }
  </style>`;
  }
  if (config.siteConfig.lang) {
    head += `
    <script>
    const locale = localStorage.getItem('valaxy-locale') || '${config.siteConfig.lang}';
    document.documentElement.setAttribute('lang', locale);
    </script>
    `;
  }
  for (const root of roots) {
    const path17 = join2(root, "index.html");
    if (!fs10.existsSync(path17))
      continue;
    const indexHtml = await fs10.readFile(path17, "utf-8");
    head += `
${(indexHtml.match(/<head>([\s\S]*?)<\/head>/i)?.[1] || "").trim()}`;
    body += `
${(indexHtml.match(/<body>([\s\S]*?)<\/body>/i)?.[1] || "").trim()}`;
  }
  main = main.replace("__ENTRY__", toAtFS(join2(clientRoot, "main.ts"))).replace("<!-- head -->", head).replace("<!-- body -->", body);
  return main;
}

// node/plugins/extendConfig.ts
var clientDeps = [
  // https://cn.vite.dev/guide/dep-pre-bundling.html#the-why
  "dayjs",
  "dayjs/locale/en",
  "dayjs/locale/zh-cn",
  "dayjs/plugin/relativeTime",
  "dayjs/plugin/timezone",
  "dayjs/plugin/utc",
  "@unhead/schema-org/vue",
  "@unhead/vue",
  "defu",
  "katex",
  "nprogress",
  "unocss",
  // vue
  "vue",
  "vue-router",
  "unplugin-vue-router/data-loaders/basic",
  "vue-i18n",
  // dev
  "@vue/devtools-api",
  // will may be addons
  "fuse.js",
  "medium-zoom",
  "vanilla-lazyload",
  "valaxy > @vueuse/integrations/useFuse"
];
var EXCLUDE = [
  "@docsearch/css",
  "@docsearch/js",
  // exclude for @waline/client/dist/component(use @vueuse/core) import
  "@vueuse/core",
  "@vueuse/shared",
  "@unocss/reset",
  "unocss",
  // addon, todo add externals for addon
  // main field error
  "meting",
  // internal
  "valaxy",
  "virtual:valaxy-addons:empty",
  "@valaxyjs/devtools",
  "/@valaxyjs/config",
  "/@valaxyjs/context",
  "/@valaxyjs/addons",
  "/@valaxyjs/locales",
  "/@valaxyjs/styles"
];
function createConfigPlugin(options) {
  const addonDeps = options.addons.map((i) => Object.keys(i.pkg.dependencies || {})).flat();
  const includedDeps = uniq3([
    ...clientDeps,
    // remove theme deps, for primevue parse entry
    // ...themeDeps,
    // addon deps
    ...addonDeps
  ]).filter((i) => !EXCLUDE.includes(i));
  return {
    name: "valaxy:site",
    // before devtools
    enforce: "pre",
    async config(config) {
      const injection = {
        // root: options.userRoot,
        // can not transform valaxy/client/*.ts when use userRoot
        root: options.clientRoot,
        // cacheDir: join(options.userRoot, 'node_modules/.vite'),
        cacheDir: join3(options.userRoot, "node_modules/.valaxy/cache"),
        publicDir: join3(options.userRoot, "public"),
        define: getDefine(options),
        resolve: {
          alias: await getAlias(options),
          dedupe: ["vue"]
        },
        optimizeDeps: {
          // do not entry node file
          entries: [resolve6(options.clientRoot, "main.ts")],
          // must need it
          include: includedDeps,
          exclude: EXCLUDE
        },
        server: {
          fs: {
            allow: uniq3([
              searchForWorkspaceRoot(options.clientRoot),
              searchForWorkspaceRoot(options.themeRoot),
              searchForWorkspaceRoot(options.userRoot),
              dirname4(await resolveImportPath("katex/package.json", true))
            ])
          }
        }
      };
      if (isInstalledGlobally) {
        injection.resolve.alias.vue = `${resolveImportPath("vue/dist/vue.esm-browser.js", true)}`;
      }
      return mergeConfig2(config, injection);
    },
    async transformIndexHtml(html) {
      html = await getIndexHtml(options, html);
      return {
        html,
        tags: []
      };
    }
  };
}
function getDefine(_options) {
  return {
    __VUE_PROD_DEVTOOLS__: false,
    __INTLIFY_PROD_DEVTOOLS__: false
  };
}
async function getAlias(options) {
  const alias = [
    { find: "~/", replacement: `${toAtFS(options.userRoot)}/` },
    { find: "valaxy/client/", replacement: `${toAtFS(options.clientRoot)}/` },
    { find: "valaxy/package.json", replacement: toAtFS(resolve6(options.clientRoot, "../package.json")) },
    { find: /^valaxy$/, replacement: toAtFS(resolve6(options.clientRoot, "index.ts")) },
    { find: "@valaxyjs/client/", replacement: `${toAtFS(options.clientRoot)}/` },
    // virtual module alias
    {
      find: /^#valaxy\/(.*)/,
      replacement: "/@valaxyjs/$1"
    },
    // import theme
    { find: "virtual:valaxy-theme", replacement: `${toAtFS(options.themeRoot)}/client/index.ts` },
    { find: `valaxy-theme-${options.theme}/client`, replacement: `${toAtFS(resolve6(options.themeRoot))}/client/index.ts` },
    { find: `valaxy-theme-${options.theme}/`, replacement: `${toAtFS(resolve6(options.themeRoot))}/` },
    { find: `valaxy-theme-${options.theme}`, replacement: `${toAtFS(resolve6(options.themeRoot))}/client/index.ts` }
  ];
  if (options.config.siteConfig.encrypt.enable) {
    alias.push(
      { find: /^vue$/, replacement: await resolveImportPath("vue/dist/vue.esm-bundler.js", true) }
    );
  }
  options.addons.forEach((addon) => {
    alias.push({
      find: `${addon.name}/client/`,
      replacement: `${toAtFS(`${resolve6(addon.root)}`)}/client/`
    });
    alias.push({
      find: `${addon.name}/App.vue`,
      replacement: `${toAtFS(resolve6(addon.root))}/App.vue`
    });
    alias.push({
      find: addon.name,
      replacement: `${toAtFS(resolve6(addon.root))}/client/index.ts`
    });
  });
  alias.push({
    find: /^valaxy-addon-(.*)$/,
    replacement: toAtFS(resolve6(options.clientRoot, "./addons/index.ts"))
  });
  return alias;
}

// node/plugins/markdown/index.ts
import { createMarkdownItAsync } from "markdown-it-async";

// node/plugins/markdown/plugins/highlight.ts
import {
  transformerCompactLineOptions,
  transformerNotationDiff,
  transformerNotationErrorLevel,
  transformerNotationFocus,
  transformerNotationHighlight
} from "@shikijs/transformers";
import { colors as colors9 } from "consola/utils";

// ../../node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/index.js
import { webcrypto as crypto } from "node:crypto";

// ../../node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// ../../node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/index.js
var POOL_SIZE_MULTIPLIER = 128;
var pool;
var poolOffset;
function fillPool(bytes) {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
    crypto.getRandomValues(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    crypto.getRandomValues(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
}
function random(bytes) {
  fillPool(bytes |= 0);
  return pool.subarray(poolOffset - bytes, poolOffset);
}
function customRandom(alphabet, defaultSize, getRandom) {
  let mask = (2 << 31 - Math.clz32(alphabet.length - 1 | 1)) - 1;
  let step = Math.ceil(1.6 * mask * defaultSize / alphabet.length);
  return (size = defaultSize) => {
    let id = "";
    while (true) {
      let bytes = getRandom(step);
      let i = step;
      while (i--) {
        id += alphabet[bytes[i] & mask] || "";
        if (id.length >= size) return id;
      }
    }
  };
}
function customAlphabet(alphabet, size = 21) {
  return customRandom(alphabet, size, random);
}
function nanoid(size = 21) {
  fillPool(size |= 0);
  let id = "";
  for (let i = poolOffset - size; i < poolOffset; i++) {
    id += urlAlphabet[pool[i] & 63];
  }
  return id;
}

// node/plugins/markdown/plugins/highlight.ts
import {
  addClassToHast,
  createHighlighter,
  isSpecialLang
} from "shiki";
var nanoid2 = customAlphabet("abcdefghijklmnopqrstuvwxyz", 10);
function attrsToLines(attrs) {
  attrs = attrs.replace(/^(?:\[.*?\])?.*?([\d,-]+).*/, "$1").trim();
  const result = [];
  if (!attrs)
    return [];
  attrs.split(",").map((v) => v.split("-").map((v2) => Number.parseInt(v2, 10))).forEach(([start, end]) => {
    if (start && end) {
      result.push(
        ...Array.from({ length: end - start + 1 }, (_, i) => start + i)
      );
    } else {
      result.push(start);
    }
  });
  return result.map((v) => ({
    line: v,
    classes: ["highlighted"]
  }));
}
async function highlight(theme, options, logger2 = console) {
  const {
    defaultHighlightLang: defaultLang = "txt",
    codeTransformers: userTransformers = []
  } = options;
  const highlighter = await createHighlighter({
    themes: typeof theme === "object" && "light" in theme && "dark" in theme ? [theme.light, theme.dark] : [theme],
    langs: [
      // load long time, about 3s
      // ...Object.keys(bundledLanguages),
      ...options.languages || [],
      ...Object.values(options.languageAlias || {})
    ],
    langAlias: options.languageAlias
  });
  await options?.shikiSetup?.(highlighter);
  const transformers = [
    transformerNotationDiff(),
    transformerNotationFocus({
      classActiveLine: "has-focus",
      classActivePre: "has-focused-lines"
    }),
    transformerNotationHighlight(),
    transformerNotationErrorLevel(),
    {
      name: "valaxy:add-class",
      pre(node) {
        addClassToHast(node, "vp-code");
      }
    },
    {
      name: "valaxy:clean-up",
      pre(node) {
        delete node.properties.tabindex;
        delete node.properties.style;
      }
    }
  ];
  const vueRE = /-vue$/;
  const lineNoStartRE = /=(\d*)/;
  const lineNoRE = /:(no-)?line-numbers(=\d*)?$/;
  const mustacheRE = /\{\{.*?\}\}/g;
  return [
    async (str, lang, attrs) => {
      const vPre = vueRE.test(lang) ? "" : "v-pre";
      lang = lang.replace(lineNoStartRE, "").replace(lineNoRE, "").replace(vueRE, "").toLowerCase() || defaultLang;
      try {
        if (!isSpecialLang(lang) && !highlighter.getLoadedLanguages().includes(lang)) {
          await highlighter.loadLanguage(lang);
        }
      } catch {
        logger2.warn(
          colors9.yellow(
            `
The language '${lang}' is not loaded, falling back to '${defaultLang}' for syntax highlighting.`
          )
        );
        lang = defaultLang;
      }
      const lineOptions = attrsToLines(attrs);
      const mustaches = /* @__PURE__ */ new Map();
      const removeMustache = (s) => {
        if (vPre)
          return s;
        return s.replace(mustacheRE, (match) => {
          let marker = mustaches.get(match);
          if (!marker) {
            marker = nanoid2();
            mustaches.set(match, marker);
          }
          return marker;
        });
      };
      const restoreMustache = (s) => {
        mustaches.forEach((marker, match) => {
          s = s.replaceAll(marker, match);
        });
        return s;
      };
      str = removeMustache(str).trimEnd();
      const highlighted = highlighter.codeToHtml(str, {
        lang,
        transformers: [
          ...transformers,
          transformerCompactLineOptions(lineOptions),
          {
            name: "valaxy:v-pre",
            pre(node) {
              if (vPre)
                node.properties["v-pre"] = "";
            }
          },
          {
            name: "valaxy:empty-line",
            code(hast) {
              hast.children.forEach((span) => {
                if (span.type === "element" && span.tagName === "span" && Array.isArray(span.properties.class) && span.properties.class.includes("line") && span.children.length === 0) {
                  span.children.push({
                    type: "element",
                    tagName: "wbr",
                    properties: {},
                    children: []
                  });
                }
              });
            }
          },
          ...userTransformers
        ],
        meta: {
          __raw: attrs
        },
        ...typeof theme === "object" && "light" in theme && "dark" in theme ? { themes: theme, defaultColor: false } : { theme }
      });
      return restoreMustache(highlighted);
    },
    highlighter.dispose
  ];
}

// ../../node_modules/.pnpm/@mdit-vue+shared@2.1.4/node_modules/@mdit-vue/shared/dist/index.mjs
var htmlEscapeMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  "'": "&#39;",
  '"': "&quot;"
};
var htmlEscapeRegexp = /[&<>'"]/g;
var htmlEscape = (str) => str.replace(
  htmlEscapeRegexp,
  (char) => htmlEscapeMap[char]
);
var resolveTitleFromToken = (token, { shouldAllowHtml, shouldEscapeText }) => {
  const children = token.children ?? [];
  const titleTokenTypes = ["text", "emoji", "code_inline"];
  if (shouldAllowHtml) {
    titleTokenTypes.push("html_inline");
  }
  const titleTokens = children.filter(
    (item) => titleTokenTypes.includes(item.type) && // filter permalink symbol that generated by markdown-it-anchor
    !item.meta?.isPermalinkSymbol
  );
  return titleTokens.reduce((result, item) => {
    if (shouldEscapeText) {
      if (item.type === "code_inline" || item.type === "text") {
        return `${result}${htmlEscape(item.content)}`;
      }
    }
    return `${result}${item.content}`;
  }, "").trim();
};
var resolveHeadersFromTokens = (tokens, {
  level,
  shouldAllowHtml,
  shouldAllowNested,
  shouldEscapeText,
  slugify: slugify2,
  format
}) => {
  const headers = [];
  const stack = [];
  const push = (header) => {
    while (stack.length !== 0 && header.level <= stack[0].level) {
      stack.shift();
    }
    if (stack.length === 0) {
      headers.push(header);
      stack.push(header);
    } else {
      stack[0].children.push(header);
      stack.unshift(header);
    }
  };
  for (let i = 0; i < tokens.length; i += 1) {
    const token = tokens[i];
    if (token.type !== "heading_open") {
      continue;
    }
    if (token.level !== 0 && !shouldAllowNested) {
      continue;
    }
    const headerLevel = Number.parseInt(token.tag.slice(1), 10);
    if (!level.includes(headerLevel)) {
      continue;
    }
    const nextToken = tokens[i + 1];
    if (!nextToken) {
      continue;
    }
    const title = resolveTitleFromToken(nextToken, {
      shouldAllowHtml,
      shouldEscapeText
    });
    const slug = token.attrGet("id") ?? slugify2(title);
    push({
      level: headerLevel,
      title: format?.(title) ?? title,
      slug,
      link: `#${slug}`,
      children: []
    });
  }
  return headers;
};
var rControl = /[\u0000-\u001f]/g;
var rSpecial = /[\s~`!@#$%^&*()\-_+=[\]{}|\\;:"'<>,.?/]+/g;
var rCombining = /[\u0300-\u036F]/g;
var slugify = (str) => str.normalize("NFKD").replace(rCombining, "").replace(rControl, "").replace(rSpecial, "-").replace(/-{2,}/g, "-").replace(/^-+|-+$/g, "").replace(/^(\d)/, "_$1").toLowerCase();

// ../../node_modules/.pnpm/@mdit-vue+plugin-headers@2.1.4/node_modules/@mdit-vue/plugin-headers/dist/index.mjs
var headersPlugin = (md3, {
  level = [2, 3],
  shouldAllowNested = false,
  slugify: slugify$1 = slugify,
  format
} = {}) => {
  const render2 = md3.renderer.render.bind(md3.renderer);
  md3.renderer.render = (tokens, options, env) => {
    env.headers = resolveHeadersFromTokens(tokens, {
      level,
      shouldAllowHtml: false,
      shouldAllowNested,
      shouldEscapeText: false,
      slugify: slugify$1,
      format
    });
    return render2(tokens, options, env);
  };
};

// ../../node_modules/.pnpm/@mdit-vue+plugin-sfc@2.1.4/node_modules/@mdit-vue/plugin-sfc/dist/index.mjs
var TAG_NAME_SCRIPT = "script";
var TAG_NAME_STYLE = "style";
var TAG_NAME_TEMPLATE = "template";
var SCRIPT_SETUP_TAG_OPEN_REGEXP = /^<script\s+.*?\bsetup\b.*?>$/is;
var createSfcRegexp = ({
  customBlocks
}) => {
  const sfcTags = Array.from(
    /* @__PURE__ */ new Set([TAG_NAME_SCRIPT, TAG_NAME_STYLE, ...customBlocks])
  ).join("|");
  return new RegExp(
    `^\\s*(?<content>(?<tagOpen><(?<type>${sfcTags})\\s?.*?>)(?<contentStripped>.*)(?<tagClose><\\/\\k<type>\\s*>))\\s*$`,
    "is"
  );
};
var sfcPlugin = (md3, { customBlocks = [] } = {}) => {
  const sfcRegexp = createSfcRegexp({ customBlocks });
  const render2 = md3.render.bind(md3);
  md3.render = (src, env = {}) => {
    env.sfcBlocks = {
      template: null,
      script: null,
      scriptSetup: null,
      scripts: [],
      styles: [],
      customBlocks: []
    };
    const rendered = render2(src, env);
    env.sfcBlocks.template = {
      type: TAG_NAME_TEMPLATE,
      content: `<${TAG_NAME_TEMPLATE}>${rendered}</${TAG_NAME_TEMPLATE}>`,
      contentStripped: rendered,
      tagOpen: `<${TAG_NAME_TEMPLATE}>`,
      tagClose: `</${TAG_NAME_TEMPLATE}>`
    };
    return rendered;
  };
  const htmlBlockRule = md3.renderer.rules.html_block;
  md3.renderer.rules.html_block = (tokens, idx, options, env, self) => {
    if (!env.sfcBlocks) {
      return htmlBlockRule(tokens, idx, options, env, self);
    }
    const token = tokens[idx];
    const content = token.content;
    const match = content.match(sfcRegexp);
    if (!match) {
      return htmlBlockRule(tokens, idx, options, env, self);
    }
    const sfcBlock = match.groups;
    if (sfcBlock.type === TAG_NAME_SCRIPT) {
      env.sfcBlocks.scripts.push(sfcBlock);
      if (SCRIPT_SETUP_TAG_OPEN_REGEXP.test(sfcBlock.tagOpen)) {
        env.sfcBlocks.scriptSetup = sfcBlock;
      } else {
        env.sfcBlocks.script = sfcBlock;
      }
    } else if (sfcBlock.type === TAG_NAME_STYLE) {
      env.sfcBlocks.styles.push(sfcBlock);
    } else {
      env.sfcBlocks.customBlocks.push(sfcBlock);
    }
    return "";
  };
};

// ../../node_modules/.pnpm/@mdit-vue+plugin-title@2.1.4/node_modules/@mdit-vue/plugin-title/dist/index.mjs
var titlePlugin = (md3) => {
  const render2 = md3.renderer.render.bind(md3.renderer);
  md3.renderer.render = (tokens, options, env) => {
    const tokenIdx = tokens.findIndex((token) => token.tag === "h1");
    env.title = tokenIdx > -1 ? resolveTitleFromToken(tokens[tokenIdx + 1], {
      shouldAllowHtml: false,
      shouldEscapeText: false
    }) : "";
    return render2(tokens, options, env);
  };
};

// ../../node_modules/.pnpm/@mdit-vue+plugin-toc@2.1.4/node_modules/@mdit-vue/plugin-toc/dist/index.mjs
var createRenderHeaders = ({
  listTag,
  listClass,
  itemClass,
  linkTag,
  linkClass
}) => {
  const listTagString = htmlEscape(listTag);
  const listClassString = listClass ? ` class="${htmlEscape(listClass)}"` : "";
  const itemTagString = "li";
  const itemClassString = itemClass ? ` class="${htmlEscape(itemClass)}"` : "";
  const linkTagString = htmlEscape(linkTag);
  const linkClassString = linkClass ? ` class="${htmlEscape(linkClass)}"` : "";
  const linkTo = (link) => linkTag === "router-link" ? ` to="${link}"` : ` href="${link}"`;
  const renderHeaders = (headers) => `<${listTagString}${listClassString}>${headers.map(
    (header) => `<${itemTagString}${itemClassString}><${linkTagString}${linkClassString}${linkTo(header.link)}>${header.title}</${linkTagString}>${header.children.length > 0 ? renderHeaders(header.children) : ""}</${itemTagString}>`
  ).join("")}</${listTagString}>`;
  return renderHeaders;
};
var createTocBlockRule = ({
  pattern,
  containerTag,
  containerClass
}) => (state, startLine, endLine, silent) => {
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  const pos = state.bMarks[startLine] + state.tShift[startLine];
  const max = state.eMarks[startLine];
  const lineFirstToken = state.src.slice(pos, max).split(" ")[0];
  if (!pattern.test(lineFirstToken)) return false;
  if (silent) return true;
  state.line = startLine + 1;
  const tokenOpen = state.push("toc_open", containerTag, 1);
  tokenOpen.markup = "";
  tokenOpen.map = [startLine, state.line];
  if (containerClass) {
    tokenOpen.attrSet("class", containerClass);
  }
  const tokenBody = state.push("toc_body", "", 0);
  tokenBody.markup = lineFirstToken;
  tokenBody.map = [startLine, state.line];
  tokenBody.hidden = true;
  const tokenClose = state.push("toc_close", containerTag, -1);
  tokenClose.markup = "";
  tokenBody.map = [startLine, state.line];
  return true;
};
var tocPlugin = (md3, {
  pattern = /^\[\[toc\]\]$/i,
  slugify: slugify$1 = slugify,
  format,
  level = [2, 3],
  shouldAllowNested = false,
  containerTag = "nav",
  containerClass = "table-of-contents",
  listTag = "ul",
  listClass = "",
  itemClass = "",
  linkTag = "a",
  linkClass = ""
} = {}) => {
  md3.block.ruler.before(
    "heading",
    "toc",
    createTocBlockRule({
      pattern,
      containerTag,
      containerClass
    }),
    {
      alt: ["paragraph", "reference", "blockquote"]
    }
  );
  const renderHeaders = createRenderHeaders({
    listTag,
    listClass,
    itemClass,
    linkTag,
    linkClass
  });
  md3.renderer.rules.toc_body = (tokens) => renderHeaders(
    resolveHeadersFromTokens(tokens, {
      level,
      shouldAllowHtml: true,
      shouldAllowNested,
      shouldEscapeText: true,
      slugify: slugify$1,
      format
    })
  );
};

// node/plugins/markdown/setup.ts
import { cssI18nContainer } from "css-i18n";
import anchorPlugin from "markdown-it-anchor";
import attrsPlugin from "markdown-it-attrs";
import { full as emojiPlugin } from "markdown-it-emoji";
import footnotePlugin from "markdown-it-footnote";
import imageFigures from "markdown-it-image-figures";
import TaskLists from "markdown-it-task-lists";

// node/plugins/markdown/plugins/link.ts
import { URL as URL2 } from "node:url";
var indexRE = /(^|.*\/)index.md(.*)$/i;
function linkPlugin(md3, externalAttrs, base) {
  md3.renderer.rules.link_open = (tokens, idx, options, env, self) => {
    const token = tokens[idx];
    const hrefIndex = token.attrIndex("href");
    if (hrefIndex >= 0) {
      const hrefAttr = token.attrs[hrefIndex];
      const url = hrefAttr[1];
      const isExternal2 = EXTERNAL_URL_RE.test(url);
      if (isExternal2) {
        Object.entries(externalAttrs).forEach(([key, val]) => {
          token.attrSet(key, val);
        });
        hrefAttr[1] = url.replace(PATHNAME_PROTOCOL_RE, "");
      } else if (
        // internal anchor links
        !url.startsWith("#") && !url.startsWith("mailto:") && !/\.(?!html|md)\w+($|\?)/i.test(url)
      ) {
        normalizeHref(hrefAttr, env);
      }
      hrefAttr[1] = hrefAttr[1].replace(/\bimport\.meta/g, "import%2Emeta").replace(/\bprocess\.env/g, "process%2Eenv");
    }
    return self.renderToken(tokens, idx, options);
  };
  function normalizeHref(hrefAttr, env) {
    let url = hrefAttr[1];
    const indexMatch = url.match(indexRE);
    if (indexMatch) {
      const [, path17, hash] = indexMatch;
      url = path17 + hash;
    } else {
      let cleanUrl = url.replace(/[?#].*$/, "");
      if (cleanUrl.endsWith(".md")) {
        cleanUrl = cleanUrl.replace(
          /\.md$/,
          env.cleanUrls === "disabled" ? ".html" : ""
        );
      }
      if (env.cleanUrls === "disabled" && !cleanUrl.endsWith(".html") && !cleanUrl.endsWith("/")) {
        cleanUrl += ".html";
      }
      const parsed = new URL2(url, "http://a.com");
      url = cleanUrl + parsed.search + parsed.hash;
    }
    if (!url.startsWith("/") && !/^\.\//.test(url))
      url = `./${url}`;
    pushLink(url.replace(/\.html$/, ""), env);
    if (url.startsWith("/"))
      url = `${base}${url}`.replace(/\/+/g, "/");
    hrefAttr[1] = decodeURI(url);
  }
  function pushLink(link, env) {
    const links = env.links || (env.links = []);
    links.push(link);
  }
}

// node/plugins/markdown/plugins/markdown-it/container.ts
import container from "markdown-it-container";

// node/plugins/markdown/plugins/markdown-it/preWrapper.ts
function extractLang(info) {
  return info.trim().replace(/=(\d*)/, "").replace(/:(no-)?line-numbers(\{| |$|=\d*).*/, "").replace(/(-vue|\{| ).*$/, "").replace(/^vue-html$/, "template").replace(/^ansi$/, "");
}
function getAdaptiveThemeMarker(options) {
  return options.hasSingleTheme ? "" : " vp-adaptive-theme";
}
function extractTitle(info, html = false) {
  if (html) {
    return info.replace(/<!--[\s\S]*?-->/g, "").match(/data-title="(.*?)"/)?.[1] || "";
  }
  return info.match(/\[(.*)\]/)?.[1] || extractLang(info) || "txt";
}
function getCodeHeightLimitStyle(options, env) {
  const codeHeightLimit = env.frontmatter?.codeHeightLimit || options?.siteConfig?.codeHeightLimit;
  if (codeHeightLimit === void 0 || codeHeightLimit <= 0)
    return "";
  return `style="max-height: ${codeHeightLimit}px;"`;
}
function preWrapperPlugin(md3, options) {
  const fence = md3.renderer.rules.fence;
  md3.renderer.rules.fence = (...args) => {
    const [tokens, idx, _, env] = args;
    const token = tokens[idx];
    token.info = token.info.replace(/\[.*\]/, "");
    const lang = extractLang(token.info);
    const rawCode = fence(...args);
    return `
    <div ${getCodeHeightLimitStyle(options, env)} class="language-${lang}${getAdaptiveThemeMarker(options)}${// eslint-disable-next-line regexp/no-unused-capturing-group
    / active( |$)/.test(token.info) ? " active" : ""}">
      <button title="Copy Code" class="copy"></button><span class="lang">${lang}</span>${rawCode}<button class="collapse"></button>
    </div>`;
  };
}

// node/plugins/markdown/plugins/markdown-it/container.ts
function createContainer(classes, { icon, color, text: defaultTitle, langs } = {}) {
  return [
    container,
    classes,
    {
      render(tokens, idx) {
        const token = tokens[idx];
        const info = token.info.trim().slice(classes.length).trim();
        if (token.nesting === 1) {
          if (classes === "details") {
            return `<details class="${classes} custom-block">${`<summary>${info}</summary>`}
`;
          }
          let iconTag = "";
          if (icon)
            iconTag = `<i class="icon ${icon}" ${color ? `style="color: ${color}"` : ""}></i>`;
          let title = `<span lang="en">${info || defaultTitle}</span>`;
          if (langs) {
            Object.keys(langs).forEach((lang) => {
              title += `<span lang="${lang}">${info || langs[lang]}</span>`;
            });
          }
          return `<div class="${classes} custom-block"><p class="custom-block-title">${iconTag}${title}</p>
`;
        } else {
          return classes === "details" ? "</details>\n" : "</div>\n";
        }
      }
    }
  ];
}
var defaultBlocksOptions = {
  tip: {
    text: "TIP",
    langs: {
      "zh-CN": "\u63D0\u793A"
    }
  },
  warning: {
    text: "WARNING",
    langs: {
      "zh-CN": "\u6CE8\u610F"
    }
  },
  danger: {
    text: "DANGER",
    langs: {
      "zh-CN": "\u8B66\u544A"
    }
  },
  info: {
    text: "INFO",
    langs: {
      "zh-CN": "\u4FE1\u606F"
    }
  },
  details: {
    text: "Details",
    langs: {
      "zh-CN": "\u8BE6\u60C5"
    }
  }
};
function containerPlugin(md3, options, containerOptions = {}) {
  Object.keys(defaultBlocksOptions).forEach((optionKey) => {
    const option = {
      ...defaultBlocksOptions[optionKey],
      ...containerOptions[optionKey] || {}
    };
    md3.use(...createContainer(optionKey, option));
  });
  md3.use(...createCodeGroup(options));
  const languages = ["zh-CN", "en"];
  languages.forEach((lang) => {
    md3.use(container, lang, {
      render: (tokens, idx) => tokens[idx].nesting === 1 ? `<div lang="${lang}">
` : "</div>\n"
    });
  });
}
function createCodeGroup(options) {
  return [
    container,
    "code-group",
    {
      render(tokens, idx) {
        if (tokens[idx].nesting === 1) {
          const name = nanoid(5);
          let tabs = "";
          let checked = 'checked="checked"';
          for (let i = idx + 1; !(tokens[i].nesting === -1 && tokens[i].type === "container_code-group_close"); ++i) {
            const isHtml = tokens[i].type === "html_block";
            if (tokens[i].type === "fence" && tokens[i].tag === "code" || isHtml) {
              const title = extractTitle(
                isHtml ? tokens[i].content : tokens[i].info,
                isHtml
              );
              if (title) {
                const id = nanoid(7);
                tabs += `<input type="radio" name="group-${name}" id="tab-${id}" ${checked}><label for="tab-${id}">${title}</label>`;
                if (checked && !isHtml)
                  tokens[i].info += " active";
                checked = "";
              }
            }
          }
          return `<div class="vp-code-group${getAdaptiveThemeMarker(
            options
          )}"><div class="tabs">${tabs}</div><div class="blocks">
`;
        }
        return `</div></div>
`;
      }
    }
  ];
}

// node/plugins/markdown/plugins/markdown-it/footnoteTooltip.ts
function footnoteTooltipPlugin(md3) {
  const originalFootnoteRef = md3.renderer.rules.footnote_ref;
  const originalFootnoteOpen = md3.renderer.rules.footnote_open;
  const originalFootnoteClose = md3.renderer.rules.footnote_close;
  const originalFootnoteAnchor = md3.renderer.rules.footnote_anchor;
  md3.renderer.rules.footnote_ref = function(tokens, idx, options, env, self) {
    const originalCode = originalFootnoteRef(tokens, idx, options, env, self);
    const href = originalCode.match(/href="(.*?)"/)[0];
    const id = originalCode.match(/id="(.*?)"/)[0];
    return `<ValaxyFootnoteRef ${href} ${id}>${originalCode}</ValaxyFootnoteRef>`;
  };
  md3.renderer.rules.footnote_open = function(tokens, idx, options, env, self) {
    const originalOpen = originalFootnoteOpen(tokens, idx, options, env, self);
    const id = originalOpen.match(/id="(.*?)"/)[0];
    return `<ValaxyFootnoteItem ${id}>${originalOpen}<ValaxyFootnoteContent>`;
  };
  md3.renderer.rules.footnote_close = function(tokens, idx, options, env, self) {
    const originalClose = originalFootnoteClose(tokens, idx, options, env, self);
    return `</ValaxyFootnoteContent>${originalClose}</ValaxyFootnoteItem>`;
  };
  md3.renderer.rules.footnote_anchor = function(tokens, idx, options, env, self) {
    const originalCode = originalFootnoteAnchor(tokens, idx, options, env, self);
    const href = originalCode.match(/href="(.*?)"/)[0];
    return `<ValaxyFootnoteAnchor ${href}>${originalCode}</ValaxyFootnoteAnchor>`;
  };
}

// node/plugins/markdown/plugins/markdown-it/highlightLines.ts
var RE = /\{([\d,-]+)\}/;
function highlightLinePlugin(md3) {
  const fence = md3.renderer.rules.fence;
  md3.renderer.rules.fence = (...args) => {
    const [tokens, idx] = args;
    const token = tokens[idx];
    const attr = token.attrs && token.attrs[0];
    let lines = null;
    if (!attr) {
      const rawInfo = token.info;
      if (!rawInfo || !RE.test(rawInfo))
        return fence(...args);
      const langName = rawInfo.replace(RE, "").trim();
      token.info = langName;
      lines = RE.exec(rawInfo)[1];
    }
    if (!lines) {
      lines = attr[0];
      if (!lines || !/[\d,-]+/.test(lines))
        return fence(...args);
    }
    token.info += ` ${lines}`;
    return fence(...args);
  };
}

// node/plugins/markdown/plugins/markdown-it/katex.ts
import katex from "katex";
function isValidDelim(state, pos) {
  const max = state.posMax;
  let can_open = true;
  let can_close = true;
  const prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;
  const nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;
  if (prevChar === 32 || prevChar === 9 || /* \t */
  nextChar >= 48 && nextChar <= 57) {
    can_close = false;
  }
  if (nextChar === 32 || nextChar === 9)
    can_open = false;
  return {
    can_open,
    can_close
  };
}
function math_inline(state, silent) {
  let match, token, res, pos;
  if (state.src[state.pos] !== "$")
    return false;
  res = isValidDelim(state, state.pos);
  if (!res.can_open) {
    if (!silent)
      state.pending += "$";
    state.pos += 1;
    return true;
  }
  const start = state.pos + 1;
  match = start;
  while ((match = state.src.indexOf("$", match)) !== -1) {
    pos = match - 1;
    while (state.src[pos] === "\\") pos -= 1;
    if ((match - pos) % 2 === 1)
      break;
    match += 1;
  }
  if (match === -1) {
    if (!silent)
      state.pending += "$";
    state.pos = start;
    return true;
  }
  if (match - start === 0) {
    if (!silent)
      state.pending += "$$";
    state.pos = start + 1;
    return true;
  }
  res = isValidDelim(state, match);
  if (!res.can_close) {
    if (!silent)
      state.pending += "$";
    state.pos = start;
    return true;
  }
  if (!silent) {
    token = state.push("math_inline", "math", 0);
    token.markup = "$";
    token.content = state.src.slice(start, match);
  }
  state.pos = match + 1;
  return true;
}
function math_block(state, start, end, silent) {
  let firstLine;
  let lastLine;
  let next;
  let lastPos;
  let found = false;
  let pos = state.bMarks[start] + state.tShift[start];
  let max = state.eMarks[start];
  if (pos + 2 > max)
    return false;
  if (state.src.slice(pos, pos + 2) !== "$$")
    return false;
  pos += 2;
  firstLine = state.src.slice(pos, max);
  if (silent)
    return true;
  if (firstLine.trim().slice(-2) === "$$") {
    firstLine = firstLine.trim().slice(0, -2);
    found = true;
  }
  for (next = start; !found; ) {
    next++;
    if (next >= end)
      break;
    pos = state.bMarks[next] + state.tShift[next];
    max = state.eMarks[next];
    if (pos < max && state.tShift[next] < state.blkIndent) {
      break;
    }
    if (state.src.slice(pos, max).trim().slice(-2) === "$$") {
      lastPos = state.src.slice(0, max).lastIndexOf("$$");
      lastLine = state.src.slice(pos, lastPos);
      found = true;
    }
  }
  state.line = next + 1;
  const token = state.push("math_block", "math", 0);
  token.block = true;
  token.content = (firstLine && firstLine.trim() ? `${firstLine}
` : "") + state.getLines(start + 1, next, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : "");
  token.map = [start, state.line];
  token.markup = "$$";
  return true;
}
function math_plugin(md3, options) {
  options = options || {};
  const katexInline = function(latex) {
    options.displayMode = false;
    try {
      return katex.renderToString(latex, options);
    } catch (error) {
      if (options.throwOnError)
        console.warn(error);
      return latex;
    }
  };
  const inlineRenderer = function(tokens, idx) {
    return katexInline(tokens[idx].content);
  };
  const katexBlock = function(latex) {
    options.displayMode = true;
    try {
      return `<p>${katex.renderToString(latex, options)}</p>`;
    } catch (error) {
      if (options.throwOnError)
        console.warn(error);
      return latex;
    }
  };
  const blockRenderer = function(tokens, idx) {
    return `${katexBlock(tokens[idx].content)}
`;
  };
  md3.inline.ruler.after("escape", "math_inline", math_inline);
  md3.block.ruler.after("blockquote", "math_block", math_block, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  });
  md3.renderer.rules.math_inline = inlineRenderer;
  md3.renderer.rules.math_block = blockRenderer;
}

// node/plugins/markdown/plugins/markdown-it/lineNumbers.ts
function lineNumberPlugin(md3, enable = false) {
  const fence = md3.renderer.rules.fence;
  md3.renderer.rules.fence = (...args) => {
    const rawCode = fence(...args);
    const [tokens, idx] = args;
    const info = tokens[idx].info;
    if (
      // eslint-disable-next-line regexp/no-unused-capturing-group
      !enable && !/:line-numbers($| |=)/.test(info) || enable && /:no-line-numbers($| )/.test(info)
    ) {
      return rawCode;
    }
    let startLineNumber = 1;
    const matchStartLineNumber = info.match(/=(\d*)/);
    if (matchStartLineNumber && matchStartLineNumber[1])
      startLineNumber = Number.parseInt(matchStartLineNumber[1]);
    const code = rawCode.slice(
      rawCode.indexOf("<code>"),
      rawCode.indexOf("</code>")
    );
    const lines = code.split("\n");
    const lineNumbersCode = [...Array.from({ length: lines.length })].map(
      (_, index) => `<span class="line-number">${index + startLineNumber}</span><br>`
    ).join("");
    const lineNumbersWrapperCode = `<div class="line-numbers-wrapper" aria-hidden="true">${lineNumbersCode}</div>`;
    const finalCode = rawCode.replace(/<\/div>$/, `${lineNumbersWrapperCode}</div>`).replace(/"(language-[^"]*)"/, '"$1 line-numbers-mode"');
    return finalCode;
  };
}

// node/plugins/markdown/plugins/markdown-it/snippet.ts
import fs11 from "fs-extra";
import path5 from "pathe";
var rawPathRegexp = /^(.+?(?:\.([a-z0-9]+))?)(#[\w-]+)?(?: ?\{(\d+(?:[,-]\d+)*)? ?(\S+)?\})? ?(?:\[(.+)\])?$/;
function rawPathToToken(rawPath) {
  const [
    filepath = "",
    extension = "",
    region = "",
    lines = "",
    lang = "",
    rawTitle = ""
  ] = (rawPathRegexp.exec(rawPath) || []).slice(1);
  const title = rawTitle || filepath.split("/").pop() || "";
  return { filepath, extension, region, lines, lang, title };
}
function dedent(text) {
  const lines = text.split("\n");
  const minIndentLength = lines.reduce((acc, line) => {
    for (let i = 0; i < line.length; i++) {
      if (line[i] !== " " && line[i] !== "	")
        return Math.min(i, acc);
    }
    return acc;
  }, Number.POSITIVE_INFINITY);
  if (minIndentLength < Number.POSITIVE_INFINITY)
    return lines.map((x) => x.slice(minIndentLength)).join("\n");
  return text;
}
function testLine(line, regexp, regionName, end = false) {
  const [full, tag, name] = regexp.exec(line.trim()) || [];
  return full && tag && name === regionName && tag.match(end ? /^[Ee]nd ?[rR]egion$/ : /^[rR]egion$/);
}
function findRegion(lines, regionName) {
  const regionRegexps = [
    /^\/\/ ?#?((?:end)?region) ([\w*-]+)$/,
    // javascript, typescript, java
    /^\/\* ?#((?:end)?region) ([\w*-]+) ?\*\/$/,
    // css, less, scss
    /^#pragma ((?:end)?region) ([\w*-]+)$/,
    // C, C++
    /^<!-- #?((?:end)?region) ([\w*-]+) -->$/,
    // HTML, markdown
    /^#(End Region) ([\w*-]+)$/,
    // Visual Basic
    /^::#(endregion) ([\w*-]+)$/,
    // Bat
    /^# ?((?:end)?region) ([\w*-]+)$/
    // C#, PHP, Powershell, Python, perl & misc
  ];
  let regexp = null;
  let start = -1;
  for (const [lineId, line] of lines.entries()) {
    if (regexp === null) {
      for (const reg of regionRegexps) {
        if (testLine(line, reg, regionName)) {
          start = lineId + 1;
          regexp = reg;
          break;
        }
      }
    } else if (testLine(line, regexp, regionName, true)) {
      return { start, end: lineId, regexp };
    }
  }
  return null;
}
function snippetPlugin(md3, srcDir) {
  const parser = (state, startLine, endLine, silent) => {
    const CH = "<".charCodeAt(0);
    const pos = state.bMarks[startLine] + state.tShift[startLine];
    const max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4)
      return false;
    for (let i = 0; i < 3; ++i) {
      const ch = state.src.charCodeAt(pos + i);
      if (ch !== CH || pos + i >= max)
        return false;
    }
    if (silent)
      return true;
    const start = pos + 3;
    const end = state.skipSpacesBack(max, pos);
    const rawPath = state.src.slice(start, end).trim().replace(/^@/, srcDir).trim();
    const { filepath, extension, region, lines, lang, title } = rawPathToToken(rawPath);
    state.line = startLine + 1;
    const token = state.push("fence", "code", 0);
    token.info = `${lang || extension}${lines ? `{${lines}}` : ""}${title ? `[${title}]` : ""}`;
    const { realPath, path: _path } = state.env;
    const resolvedPath = path5.resolve(path5.dirname(realPath ?? _path), filepath);
    token.src = [resolvedPath, region.slice(1)];
    token.markup = "```";
    token.map = [startLine, startLine + 1];
    return true;
  };
  const fence = md3.renderer.rules.fence;
  md3.renderer.rules.fence = (...args) => {
    const [tokens, idx, , { includes }] = args;
    const token = tokens[idx];
    const [src, regionName] = token.src ?? [];
    if (!src)
      return fence(...args);
    if (includes)
      includes.push(src);
    const isAFile = fs11.statSync(src).isFile();
    if (!fs11.existsSync(src) || !isAFile) {
      token.content = isAFile ? `Code snippet path not found: ${src}` : `Invalid code snippet option`;
      token.info = "";
      return fence(...args);
    }
    let content = fs11.readFileSync(src, "utf8");
    if (regionName) {
      const lines = content.split(/\r?\n/);
      const region = findRegion(lines, regionName);
      if (region) {
        content = dedent(
          lines.slice(region.start, region.end).filter((line) => !region.regexp.test(line.trim())).join("\n")
        );
      }
    }
    token.content = content;
    return fence(...args);
  };
  md3.block.ruler.before("fence", "snippet", parser);
}

// node/plugins/markdown/setup.ts
var defaultCodeTheme = { light: "github-light", dark: "github-dark" };
async function setupMarkdownPlugins(md3, options, base = "/") {
  const mdOptions = options?.config.markdown || {};
  const theme = mdOptions.theme ?? defaultCodeTheme;
  const hasSingleTheme = typeof theme === "string" || "name" in theme;
  const siteConfig = options?.config.siteConfig || {};
  if (mdOptions.preConfig)
    mdOptions.preConfig(md3);
  md3.use(highlightLinePlugin).use(preWrapperPlugin, { theme, siteConfig }).use(snippetPlugin, options?.userRoot).use(containerPlugin, {
    hasSingleTheme
  }, {
    ...mdOptions.blocks,
    ...mdOptions?.container
  }).use(cssI18nContainer, {
    languages: options?.config.siteConfig.languages
  }).use(
    linkPlugin,
    {
      target: "_blank",
      rel: "noreferrer",
      ...mdOptions.externalLinks
    },
    base
  );
  md3.use(lineNumberPlugin, mdOptions.lineNumbers);
  if (!mdOptions.attrs?.disable)
    md3.use(attrsPlugin, mdOptions.attrs);
  md3.use(emojiPlugin).use(footnotePlugin).use(footnoteTooltipPlugin);
  md3.use(anchorPlugin, {
    slugify,
    permalink: anchorPlugin.permalink.linkInsideHeader({
      symbol: "&ZeroWidthSpace;",
      renderAttrs: (slug, state) => {
        const idx = state.tokens.findIndex((token) => {
          const attrs = token.attrs;
          const id = attrs?.find((attr) => attr[0] === "id");
          return id && slug === id[1];
        });
        const title = state.tokens[idx + 1].content;
        return {
          "aria-label": `Permalink to "${title}"`
        };
      }
    }),
    ...mdOptions.anchor
  });
  md3.use(headersPlugin, {
    slugify,
    ...typeof mdOptions.headers === "boolean" ? void 0 : mdOptions.headers
  }).use(sfcPlugin, {
    ...mdOptions.sfc
  }).use(titlePlugin).use(tocPlugin, {
    ...mdOptions.toc
  });
  md3.use(math_plugin, mdOptions.katex);
  const vanillaLazyload = options?.config.siteConfig.vanillaLazyload || { enable: false };
  md3.use(imageFigures, {
    figcaption: true,
    // default web performance recommended settings
    lazy: true,
    async: true,
    // removeSrc and classes are required by vanilla-lazyload
    ...vanillaLazyload.enable ? {
      lazy: true,
      async: true,
      classes: "lazy"
      // when removeSrc, vite can not handle relative path
      // removeSrc in useVanillaLazyload onMounted
      // removeSrc: true,
    } : {},
    ...mdOptions.imageFigures
  });
  md3.use(TaskLists);
  if (options?.config.groupIcons) {
    const { groupIconMdPlugin } = await import("vitepress-plugin-group-icons");
    md3.use(groupIconMdPlugin, {
      titleBar: { includeSnippet: true }
    });
  }
  if (mdOptions.config)
    mdOptions.config(md3);
  return md3;
}

// node/plugins/markdown/transform/index.ts
import Markdown from "unplugin-vue-markdown/vite";

// node/app/state.ts
var StateManager = class {
  /**
   * @zh  ID 
   */
  idMap = /* @__PURE__ */ new Map();
};

// node/app/class.ts
var Valaxy = class {
  /**
   * version
   */
  static version = version;
  /**
   * file state
   */
  static state = new StateManager();
  constructor() {
  }
};

// node/plugins/markdown/transform/include.ts
import { slash as slash2 } from "@antfu/utils";
import path7 from "pathe";

// node/plugins/markdown/utils/html.ts
import process6 from "node:process";
var KNOWN_EXTENSIONS = /* @__PURE__ */ new Set();
function treatAsHtml(filename) {
  if (KNOWN_EXTENSIONS.size === 0) {
    const extraExts = typeof process6 === "object" && process6.env.VITE_EXTRA_EXTENSIONS || process6.env?.VITE_EXTRA_EXTENSIONS || "";
    `3g2,3gp,aac,ai,apng,au,avif,bin,bmp,cer,class,conf,crl,css,csv,dll,doc,eps,epub,exe,gif,gz,ics,ief,jar,jpe,jpeg,jpg,js,json,jsonld,m4a,man,mid,midi,mjs,mov,mp2,mp3,mp4,mpe,mpeg,mpg,mpp,oga,ogg,ogv,ogx,opus,otf,p10,p7c,p7m,p7s,pdf,png,ps,qt,roff,rtf,rtx,ser,svg,t,tif,tiff,tr,ts,tsv,ttf,txt,vtt,wav,weba,webm,webp,woff,woff2,xhtml,xml,yaml,yml,zip${extraExts && typeof extraExts === "string" ? `,${extraExts}` : ""}`.split(",").forEach((ext2) => KNOWN_EXTENSIONS.add(ext2));
  }
  const ext = filename.split(".").pop();
  return ext == null || !KNOWN_EXTENSIONS.has(ext.toLowerCase());
}

// node/plugins/markdown/utils/processInclude.ts
import path6 from "node:path";
import fs12 from "fs-extra";
function processIncludes(srcDir, src, file) {
  const includesRE = /<!--\s*@include:\s*(.*?)\s*-->/g;
  const rangeRE = /\{(\d*),(\d*)\}$/;
  return src.replace(includesRE, (m, m1) => {
    if (!m1.length)
      return m;
    const range = m1.match(rangeRE);
    range && (m1 = m1.slice(0, -range[0].length));
    const atPresent = m1[0] === "@";
    try {
      const includePath = atPresent ? path6.join(srcDir, m1.slice(m1[1] === "/" ? 2 : 1)) : path6.join(path6.dirname(file), m1);
      let content = fs12.readFileSync(includePath, "utf-8");
      if (range) {
        const [, startLine, endLine] = range;
        const lines = content.split(/\r?\n/);
        content = lines.slice(
          startLine ? Number.parseInt(startLine, 10) - 1 : void 0,
          endLine ? Number.parseInt(endLine, 10) : void 0
        ).join("\n");
      }
      content = `<!-- @included: ${m1} -->
${content}`;
      return processIncludes(srcDir, content, includePath);
    } catch (error) {
      return m;
    }
  });
}

// node/plugins/markdown/transform/include.ts
var includedRE = /<!--\s*@included:\s*(.*?)\s*-->/g;
function createTransformIncludes(options) {
  const srcDir = options.userRoot;
  return (code, id) => {
    const fileOrig = id;
    return processIncludes(srcDir, code, fileOrig);
  };
}
function resolveTransformIncludes(code, id, options) {
  const includes = [];
  const dir = path7.dirname(id);
  code = code.replace(includedRE, (m, m1) => {
    const atPresent = m1.startsWith("@");
    const includePath = atPresent ? path7.resolve(options.userRoot, m1.slice(m1[1] === "/" ? 2 : 1)) : path7.join(dir, m1);
    includes.push(slash2(includePath));
    return "";
  });
  return {
    code,
    includes
  };
}

// node/plugins/markdown/transform/mermaid.ts
import * as base64 from "js-base64";
function transformMermaid(md3) {
  md3 = md3.replace(/^````txt\n```mermaid/gm, "````txt\n\\`\\`\\`mermaid");
  md3 = md3.replace(/^```mermaid\s*?(\{.*?\})?\n([\s\S]+?)\n```/gm, (full, options = "", code = "") => {
    code = code.trim();
    options = options.trim() || "{}";
    const encoded = base64.encode(code, true);
    return `<ValaxyMermaid :code="'${encoded}'" v-bind="${options}" />`;
  });
  md3 = md3.replace(/^````txt\n\\`\\`\\`mermaid/gm, "````txt\n```mermaid");
  return md3;
}

// node/plugins/markdown/transform/index.ts
var md;
var _disposeHighlighter;
function disposeMdItInstance() {
  if (md) {
    md = void 0;
    _disposeHighlighter?.();
  }
}
async function createMarkdownPlugin(options) {
  const mdOptions = options?.config.markdown || {};
  const theme = mdOptions.theme ?? defaultCodeTheme;
  const transformIncludes = createTransformIncludes(options);
  const [highlight2, dispose] = mdOptions.highlight ? [mdOptions.highlight, () => {
  }] : await highlight(theme, mdOptions, logger);
  _disposeHighlighter = dispose;
  return Markdown({
    include: [/\.md$/],
    wrapperClasses: "",
    // headEnabled: false,
    frontmatter: true,
    exportFrontmatter: false,
    frontmatterOptions: { grayMatterOptions: matterOptions },
    // v-pre
    escapeCodeTagInterpolation: true,
    markdownItOptions: {
      quotes: `""''`,
      html: true,
      xhtmlOut: true,
      linkify: true,
      highlight: highlight2,
      ...mdOptions?.markdownItOptions
    },
    async markdownItSetup(mdIt) {
      mdIt.linkify.set({ fuzzyLink: false });
      await setupMarkdownPlugins(mdIt, options);
      options?.config.markdown?.markdownItSetup?.(mdIt);
      function initEnv(md3) {
        md3.core.ruler.push("valaxy_md_env", (state) => {
          Valaxy.state.idMap.set(state.env.id, {
            id: state.env.id,
            title: state.env.title,
            links: state.env.links,
            headers: state.env.headers,
            frontmatter: state.env.frontmatter
          });
        });
      }
      mdIt.use(initEnv);
    },
    transforms: {
      before(code, id) {
        code = transformMermaid(code);
        code = transformIncludes(code, id);
        return code;
      }
    },
    ...mdOptions
  });
}

// node/plugins/markdown/index.ts
var md2;
var _disposeHighlighter2;
function disposePreviewMdItInstance() {
  if (md2) {
    md2 = void 0;
    _disposeHighlighter2?.();
  }
}

// node/plugins/patchTransform.ts
import { objectEntries } from "@antfu/utils";
function createFixPlugins(options) {
  const define = objectEntries(getDefine(options));
  return [
    {
      name: "valaxy:flags",
      enforce: "pre",
      transform(code, id) {
        if (id.match(/\.vue($|\?)/)) {
          const original = code;
          define.forEach(([from, to]) => {
            code = code.replace(new RegExp(from, "g"), to);
          });
          if (original !== code)
            return code;
        }
      }
    }
  ];
}

// node/plugins/setupClient.ts
import { existsSync } from "node:fs";
import { join as join4, resolve as resolve7 } from "node:path";
import { slash as slash3, uniq as uniq4 } from "@antfu/utils";
function createClientSetupPlugin({ clientRoot, themeRoot, userRoot: userRoot2 }) {
  const setupEntry = slash3(resolve7(clientRoot, "setup"));
  return {
    name: "valaxy:setup",
    enforce: "pre",
    async transform(code, id) {
      if (id.startsWith(setupEntry)) {
        const name = id.slice(setupEntry.length + 1).replace(/\?.*$/, "");
        const imports = [];
        const injections = [];
        const setups = uniq4([
          themeRoot,
          userRoot2
        ]).map((i) => join4(i, "setup", name));
        setups.forEach((path17, idx) => {
          if (!existsSync(path17))
            return;
          imports.push(`import __n${idx} from '${toAtFS(path17)}'`);
          let fn = `__n${idx}`;
          if (/\binjection_return\b/.test(code))
            fn = `injection_return = ${fn}`;
          if (/\binjection_arg\b/.test(code))
            fn += "(injection_arg)";
          else
            fn += "()";
          injections.push(
            `// ${path17}`,
            fn
          );
        });
        code = code.replace("/* __imports__ */", imports.join("\n"));
        code = code.replace("/* __injections__ */", injections.join("\n"));
        return code;
      }
      return null;
    }
  };
}

// node/plugins/unocss.ts
import { resolve as resolve9 } from "node:path";
import defu3 from "defu";
import fs14 from "fs-extra";
import { createJiti as createJiti3 } from "jiti";
import {
  presetAttributify,
  presetIcons,
  presetTypography,
  presetUno,
  transformerDirectives,
  transformerVariantGroup
} from "unocss";

// node/plugins/setupNode.ts
import { resolve as resolve8 } from "node:path";
import { isObject } from "@antfu/utils";
import fs13 from "fs-extra";
import { createJiti as createJiti2 } from "jiti";
var jiti2 = createJiti2(import.meta.url);
function deepMerge(a, b, rootPath = "") {
  a = { ...a };
  Object.keys(b).forEach((key) => {
    if (isObject(a[key]))
      a[key] = deepMerge(a[key], b[key], rootPath ? `${rootPath}.${key}` : key);
    else if (Array.isArray(a[key]))
      a[key] = [...a[key], ...b[key]];
    else
      a[key] = b[key];
  });
  return a;
}
async function loadSetups(roots, name, arg, initial, merge = true) {
  let returns = initial;
  for (const root of roots) {
    const path17 = resolve8(root, "setup", name);
    if (fs13.existsSync(path17)) {
      const setup = await jiti2.import(path17, { default: true });
      const result = await setup(arg);
      if (result !== null) {
        returns = merge ? deepMerge(returns, result) : result;
      }
    }
  }
  return returns;
}

// node/plugins/unocss.ts
var jiti3 = createJiti3(import.meta.url);
async function createSafelist(options) {
  const { config } = options;
  const safeIcons = [
    "i-ri-clipboard-line",
    "i-ri-archive-line",
    "i-ri-folder-2-line",
    "i-ri-price-tag-3-line",
    "i-ri-cloud-line"
  ];
  const safelist = [
    "animate-fade-in",
    "m-auto",
    "text-left",
    "rotate-y-180",
    ...safeIcons,
    ...options.config.unocss?.safelist ?? []
  ];
  if (options.mode === "dev") {
    const { safelist: devtoolsSafelist = [] } = await import("@valaxyjs/devtools");
    safelist.push(
      ...devtoolsSafelist
    );
  }
  const siteConfig = config.siteConfig;
  if (config.markdown?.blocks) {
    const blocks = config.markdown.blocks;
    Object.entries(blocks).forEach(([_key, block]) => {
      if (block.icon)
        safelist.push(block.icon);
    });
  }
  if (siteConfig.social?.length)
    siteConfig.social.forEach((item) => safelist.push(item?.icon || ""));
  const methods = siteConfig.sponsor?.methods || [];
  if (methods.length)
    methods.forEach((item) => safelist.push(item?.icon || ""));
  return safelist;
}
async function createUnocssConfig(options) {
  const { config: pluginOptions } = options;
  const unocssConfig = {
    shortcuts: [
      ["flex-center", "flex items-center justify-center"],
      ["inline-flex-center", "inline-flex items-center justify-center"],
      ["btn", "px-4 py-1 rounded inline-block bg-$va-c-primary text-white cursor-pointer transition hover:bg-$va-c-primary-light disabled:cursor-default disabled:bg-gray-600 disabled:opacity-50"],
      ["va-card", "shadow hover:shadow-lg bg-$va-c-bg-light"]
    ],
    presets: [
      presetUno(pluginOptions.unocssPresets?.uno),
      presetAttributify(pluginOptions.unocssPresets?.attributify),
      presetIcons({
        scale: 1.2,
        // warn: true,
        ...pluginOptions.unocssPresets?.icons
      }),
      presetTypography(pluginOptions.unocssPresets?.typography)
      // web fonts is so big, so we disable it, let the user decide
      // presetWebFonts({
      //   fonts: {
      //     serif: [
      //       {
      //         name: 'Noto Serif SC',
      //         weights: [900],
      //       },
      //     ],
      //   },
      // }),
    ],
    rules: [
      // more see 'valaxy/client/styles/global/helper.scss'
      ["font-serif", {
        "font-family": "var(--va-font-serif)"
      }],
      ["font-sans", {
        "font-family": "var(--va-font-sans)"
      }],
      ["font-mono", {
        "font-family": "var(--va-font-mono)"
      }]
    ],
    transformers: [
      transformerDirectives(),
      transformerVariantGroup()
    ],
    safelist: await createSafelist(options)
  };
  return unocssConfig;
}
async function createUnocssPlugin(options) {
  const UnoCSS = await import("unocss/vite").then((r) => r.default);
  const { unocss: unoOptions } = options.config;
  const defaultConfig = await createUnocssConfig(options);
  const { themeRoot, clientRoot, roots } = options;
  const unoConfigFiles = ["uno.config.ts", "unocss.config.ts"];
  const configFiles = [];
  const dirs = [themeRoot, clientRoot];
  dirs.forEach(
    (dir) => unoConfigFiles.forEach(
      (file) => configFiles.push(resolve9(dir, file))
    )
  );
  let config = {};
  const configDeps = [];
  for (const configFile of configFiles) {
    if (await fs14.exists(configFile)) {
      const uConfig = await jiti3.import(configFile, { default: true });
      config = defu3(config, uConfig);
      configDeps.push(configFile);
    }
  }
  config = await loadSetups(roots, "unocss.ts", {}, config, true);
  return UnoCSS({
    configDeps,
    configFile: false,
    ...defu3(unoOptions || {}, config, defaultConfig)
  });
}

// node/plugins/valaxy/index.ts
import { consola as consola12 } from "consola";
import { colors as colors11 } from "consola/utils";
import fs19 from "fs-extra";
import { join as join7, relative, resolve as resolve10 } from "pathe";

// node/virtual/addons.ts
import fs15 from "fs-extra";
import pascalCase from "pascalcase";
import { join as join5 } from "pathe";
var templateAddons = {
  id: "/@valaxyjs/addons",
  async getContent(options) {
    const globalAddonComponents = options.addons.filter((v) => v.global).filter((v) => fs15.existsSync(join5(v.root, "./App.vue")));
    const spliceImportName = (str) => `Addon${pascalCase(str)}App`;
    const imports = globalAddonComponents.map((addon) => `import ${spliceImportName(addon.name)} from "${addon.name}/App.vue"`).join("\n");
    const components = globalAddonComponents.map((addon) => `{ component: ${spliceImportName(addon.name)}, props: ${JSON.stringify(addon.props)} }`).join(",");
    return `${imports}
export default [${components}]`;
  }
};

// node/virtual/config.ts
var templateConfig = {
  id: "/@valaxyjs/config",
  async getContent(options) {
    const routes = options.redirects.map((redirect) => {
      return {
        path: redirect.from,
        redirect: redirect.to
      };
    });
    options.config.runtimeConfig.redirects = {
      useVueRouter: isProd() ? options.config.siteConfig.redirects.useVueRouter : true,
      redirectRoutes: routes
    };
    return `export default ${JSON.stringify(JSON.stringify(options.config))}`;
  }
};

// node/virtual/locales.ts
import fs16 from "fs-extra";
var templateLocales = {
  id: "/@valaxyjs/locales",
  async getContent({ roots }) {
    const imports = [
      'import { createDefu } from "defu"',
      'const messages = { "zh-CN": {}, en: {} }',
      `
  const replaceArrMerge = createDefu((obj, key, value) => {
    if (key && obj[key] && Array.isArray(obj[key]) && Array.isArray(value)) {
      obj[key] = value
      return true
    }
  })
  `
    ];
    const languages = ["zh-CN", "en"];
    roots.forEach((root, i) => {
      languages.forEach((lang) => {
        const langYml = `${root}/locales/${lang}.yml`;
        if (fs16.existsSync(langYml) && fs16.readFileSync(langYml, "utf-8")) {
          const varName = lang.replace("-", "") + i;
          imports.unshift(`import ${varName} from "${toAtFS(langYml)}"`);
          imports.push(`messages['${lang}'] = replaceArrMerge(${varName}, messages['${lang}'])`);
        }
      });
    });
    imports.push("export default messages");
    return imports.join("\n");
  }
};

// node/virtual/styles.ts
import { existsSync as existsSync2 } from "node:fs";
import { join as join6 } from "node:path";
var templateStyles = {
  id: "/@valaxyjs/styles",
  async getContent({ clientRoot, roots, config }) {
    function resolveUrlOfClient(name) {
      return toAtFS(join6(clientRoot, name));
    }
    const imports = [];
    if (config.features?.katex) {
      imports.push(`import "${await resolveImportUrl("katex/dist/katex.min.css")}"`);
      imports.push(`import "${resolveUrlOfClient("styles/third/katex.scss")}"`);
    }
    for (const root of roots) {
      const styles = [
        join6(root, "styles", "index.ts"),
        join6(root, "styles", "index.css"),
        join6(root, "styles", "index.scss")
      ];
      for (const style of styles) {
        if (existsSync2(style)) {
          imports.push(`import "${toAtFS(style)}"`);
          continue;
        }
      }
    }
    imports.unshift(`import "${await resolveImportUrl("@unocss/reset/tailwind-compat.css")}"`);
    return imports.join("\n");
  }
};

// node/virtual/index.ts
var templates = [
  templateAddons,
  templateConfig,
  templateLocales,
  templateStyles
];

// node/plugins/markdown/markdownToVue.ts
import _debug2 from "debug";
import { LRUCache } from "lru-cache";
import path11 from "pathe";

// node/app/index.ts
import { createHooks } from "hookable";
var buildHooks = [
  "build:before",
  "build:after"
];
function createValaxyNode(options) {
  const hooks = createHooks();
  if (typeof options.config.hooks === "object") {
    Object.keys(options.config.hooks).forEach((name) => {
      const hookName = name;
      const hook = options.config.hooks[hookName];
      if (typeof hook !== "function")
        return;
      if (buildHooks.includes(hookName)) {
        if (options.mode === "build")
          hooks.hook(hookName, hook);
      } else {
        hooks.hook(hookName, hook);
      }
    });
  }
  const valaxyNode = {
    version,
    hooks,
    hook: hooks.hook,
    options
  };
  options.addons.forEach((addon) => {
    if (typeof addon.setup === "function")
      addon.setup(valaxyNode);
  });
  return valaxyNode;
}

// node/plugins/markdown/transform/code-block.ts
function handleCodeHeightLimit(mainContentMd, options, codeHeightLimit) {
  if (typeof codeHeightLimit !== "number" || codeHeightLimit <= 0)
    return mainContentMd;
  const siteConfigLimit = options.config.siteConfig.codeHeightLimit;
  mainContentMd = mainContentMd.replaceAll(/<div.+class="language-\w+">/g, (matchStr) => {
    if (siteConfigLimit !== void 0 && siteConfigLimit > 0)
      matchStr = matchStr.replace(/\d+/, codeHeightLimit.toString());
    else matchStr = `${matchStr.slice(0, 5)}style="max-height: ${codeHeightLimit}px;"${matchStr.slice(5)}`;
    return matchStr;
  });
  return mainContentMd;
}
function createTransformCodeBlock(options) {
  return (code, id) => {
    const fileInfo = Valaxy.state.idMap.get(id);
    return handleCodeHeightLimit(code, options, fileInfo?.frontmatter.codeHeightLimit);
  };
}

// node/plugins/markdown/transform/dead-links.ts
import { slash as slash4 } from "@antfu/utils";
import fs17 from "fs-extra";
import path8 from "pathe";
function createScanDeadLinks(options) {
  const srcDir = path8.resolve(options.userRoot, "pages");
  const { ignoreDeadLinks } = options.config.build;
  const publicDir = options.config.vite?.publicDir || "public";
  return (code, id) => {
    const fileInfo = Valaxy.state.idMap.get(id);
    const { links = [] } = fileInfo || {};
    const fileOrig = id;
    const file = id;
    const deadLinks = [];
    const recordDeadLink = (url) => {
      deadLinks.push({ url, file: path8.relative(srcDir, fileOrig) });
    };
    function shouldIgnoreDeadLink(url) {
      if (!ignoreDeadLinks)
        return false;
      if (ignoreDeadLinks === true)
        return true;
      if (ignoreDeadLinks === "localhostLinks")
        return url.replace(EXTERNAL_URL_RE, "").startsWith("//localhost");
      return ignoreDeadLinks.some((ignore) => {
        if (typeof ignore === "string")
          return url === ignore;
        if (ignore instanceof RegExp)
          return ignore.test(url);
        if (typeof ignore === "function")
          return ignore(url);
        return false;
      });
    }
    if (links) {
      const dir = path8.dirname(file);
      for (let url of links) {
        const { pathname } = new URL(url, "http://a.com");
        if (!treatAsHtml(pathname))
          continue;
        url = url.replace(/[?#].*$/, "").replace(/\.(html|md)$/, "");
        if (url.endsWith("/"))
          url += `index`;
        const resolved = decodeURIComponent(
          slash4(
            url.startsWith("/") ? url.slice(1) : path8.relative(srcDir, path8.resolve(dir, url))
          )
          // /index => /
        ).replace(/\/index$/, "");
        if (!options.pages.includes(resolved) && !fs17.existsSync(path8.resolve(dir, publicDir, `${resolved}.html`)) && !shouldIgnoreDeadLink(url)) {
          recordDeadLink(url);
        }
      }
    }
    return deadLinks;
  };
}

// node/utils/encrypt.ts
import { webcrypto as webcrypto2 } from "node:crypto";
function getKeyMaterial(password) {
  const enc = new TextEncoder();
  return webcrypto2.subtle.importKey(
    "raw",
    enc.encode(password),
    "PBKDF2",
    false,
    ["deriveBits", "deriveKey"]
  );
}
function getKey(keyMaterial, salt) {
  return webcrypto2.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt,
      iterations: 1e5,
      hash: "SHA-256"
    },
    keyMaterial,
    {
      name: "AES-CBC",
      length: 256
    },
    true,
    ["encrypt", "decrypt"]
  );
}
async function encryptContent(content, options) {
  const { password, iv, salt } = options;
  const keyMaterial = await getKeyMaterial(password);
  const key = await getKey(keyMaterial, salt);
  const enc = new TextEncoder();
  const ciphertextData = await webcrypto2.subtle.encrypt(
    {
      name: "AES-CBC",
      iv
    },
    key,
    enc.encode(content)
  );
  return String.fromCharCode(...new Uint8Array(ciphertextData));
}

// node/plugins/markdown/transform/encrypt.ts
function createTransformEncrypt(options) {
  const { config: { siteConfig: { encrypt } } } = options;
  return async (code, id, pageData) => {
    const { frontmatter = {} } = pageData;
    if (encrypt.enable) {
      let getValaxyDecryptTemplate2 = function(options2) {
        return [
          "<ClientOnly>",
          `<ValaxyDecrypt :encrypted-content="${options2.encryptedContent}" hint="${options2.hint}" />`,
          "</ClientOnly>"
        ].join("");
      };
      var getValaxyDecryptTemplate = getValaxyDecryptTemplate2;
      const encryptRegexp = /<!-- valaxy-encrypt-start:(?<password>\w+) -->(?<content>.*?)<!-- valaxy-encrypt-end -->/gs;
      const encryptCommentRegexp = /((<!-- valaxy-encrypt-start:\w+ -->)|(<!-- valaxy-encrypt-end -->))/g;
      if (frontmatter.password) {
        code = code.replaceAll(encryptCommentRegexp, "");
      } else {
        const partiallyEncryptedContents = [];
        for (const matchArr of code.matchAll(encryptRegexp)) {
          partiallyEncryptedContents.push(
            await encryptContent(matchArr.groups.content, {
              password: matchArr.groups.password,
              iv: encrypt.iv,
              salt: encrypt.salt
            })
          );
        }
        let i = 0;
        if (partiallyEncryptedContents.length) {
          frontmatter.partiallyEncryptedContents = partiallyEncryptedContents;
          code = code.replaceAll(encryptRegexp, () => {
            const partiallyEncryptedContents2 = `$partiallyEncryptedContents`;
            const content = `${partiallyEncryptedContents2}[${i++}]`;
            return getValaxyDecryptTemplate2({
              encryptedContent: content,
              hint: frontmatter.password_hint || ""
            });
          });
        }
      }
      if (frontmatter.password) {
        const templateStart = code.indexOf("<template>");
        const templateEnd = code.lastIndexOf("</template>");
        const content = code.slice(templateStart + 10, templateEnd);
        const encryptedContent = await encryptContent(content, {
          password: frontmatter.password,
          iv: encrypt.iv,
          salt: encrypt.salt
        });
        frontmatter.encryptedContent = encryptedContent;
        frontmatter.encrypt = true;
        delete frontmatter.password;
        const encryptedContentStr = "$encryptedContent";
        code = code.replace(content, getValaxyDecryptTemplate2({
          encryptedContent: encryptedContentStr,
          hint: frontmatter.password_hint
        }));
        const scriptSetupStart = code.lastIndexOf("<script setup>");
        const scriptSetupEnd = code.lastIndexOf("</script>");
        const scriptSetupContent = code.slice(scriptSetupStart + 14, scriptSetupEnd);
        code = code.replace(scriptSetupContent, "");
      }
      if (frontmatter.gallery_password) {
        const encryptedPhotos = await encryptContent(JSON.stringify(frontmatter.photos), {
          password: frontmatter.gallery_password,
          iv: encrypt.iv,
          salt: encrypt.salt
        });
        frontmatter.encryptedPhotos = encryptedPhotos;
        delete frontmatter.gallery_password;
        delete frontmatter.photos;
      }
    }
    return code;
  };
}

// node/plugins/markdown/transform/footnoteTooltip.ts
function transformFootnoteTooltip(code, _id) {
  const footnoteContentMap = /* @__PURE__ */ new Map();
  return code.replace(/<ValaxyFootnoteItem id="(.*?)">(.*?)<\/ValaxyFootnoteItem>/gs, (_, id, content) => {
    const tooltipContent = content.match(/<ValaxyFootnoteContent>(.*?)<\/ValaxyFootnoteContent>/s)[1].replace(/<ValaxyFootnoteAnchor.*?>(.*?)<\/ValaxyFootnoteAnchor>/gs, "");
    const itemContent = content.replace(/<ValaxyFootnoteContent>(.*?)<\/ValaxyFootnoteContent>/gs, (_2, content2) => content2).replace(/<ValaxyFootnoteAnchor.*?>(.*?)<\/ValaxyFootnoteAnchor>/gs, (_2, anchor) => anchor);
    footnoteContentMap.set(id, tooltipContent);
    return itemContent;
  }).replace(/<ValaxyFootnoteRef href="#(.*?)".*?>(.*?)<\/ValaxyFootnoteRef>/gs, (_, href, content) => {
    return `<ValaxyFootnoteTooltip>${content}<template #popper>${footnoteContentMap.get(href)}</template></ValaxyFootnoteTooltip>`;
  });
}

// node/plugins/markdown/transform/hexo.ts
import { consola as consola11 } from "consola";
import { colors as colors10 } from "consola/utils";
function transformHexoTags(code, id) {
  if (code.includes("{%") && code.includes("%}")) {
    consola11.error(
      `${`${id}
`}        Please ${colors10.red("remove")} ${colors10.cyan("{% %}")}, because it conflicts with ${colors10.yellow("markdown-it-attrs")}.`
    );
  }
  code.replace("{%", "{%");
  code.replace("%}", "%}");
  return code;
}

// node/plugins/markdown/transform/markdown.ts
import path9 from "node:path";
import fs18 from "fs-extra";
function genProvideCode(name, data) {
  return [
    `const $${name} = ${transformObject(data)}`,
    `route.meta.$${name} = $${name}`,
    `provide('valaxy:${name}', $${name})`
  ];
}
var encryptedKeys = ["encryptedContent", "partiallyEncryptedContents", "encryptedPhotos"];
function injectPageDataCode(pageData) {
  const vueContextImports = [
    `import { provide } from 'vue'`,
    `import { useRoute, useRouter } from 'vue-router'`,
    "const { data: pageData } = usePageData()",
    "const router = useRouter()",
    "const route = useRoute()",
    // $frontmatter contain runtime added data, will be deleted (for example, $frontmatter.partiallyEncryptedContents)
    `const $frontmatter = Object.assign(route.meta.frontmatter || {}, pageData.value?.frontmatter || {})
    router.currentRoute.value.data = pageData.value

    provide('valaxy:frontmatter', $frontmatter)
    `
  ];
  for (const key of encryptedKeys) {
    if (pageData.frontmatter[key]) {
      vueContextImports.push(...genProvideCode(key, pageData.frontmatter[key]));
    }
  }
  return vueContextImports;
}
function createTransformMarkdown(options) {
  const loaderVuePath = path9.resolve(options.clientRoot, "templates", "loader.vue");
  const loaderVue = fs18.readFileSync(loaderVuePath, "utf-8");
  return (code, id, pageData) => {
    const isDev = options.mode === "dev";
    if (!isDev) {
      delete pageData.filePath;
    }
    const dataCode = injectPageDataCode(pageData);
    const imports = [
      ...dataCode,
      isDev ? `globalThis.$pageData = pageData` : "",
      "globalThis.$frontmatter = $frontmatter"
    ];
    encryptedKeys.forEach((key) => {
      delete pageData.frontmatter[key];
    });
    const pagePath = pageData.relativePath.slice("/pages".length - 1, -".md".length);
    const customDataLoader = loaderVue.replace("/relativePath", pagePath.endsWith("index") ? pagePath.replace(/\/index$/, "") : pagePath).replace("// custom basic loader", `return ${transformObject(pageData)}`);
    code = customDataLoader + code;
    const scriptSetupStart = code.indexOf("<script setup>");
    if (scriptSetupStart !== -1)
      code = code.slice(0, scriptSetupStart + "<script setup>".length) + imports.join("\n") + code.slice(scriptSetupStart + 14);
    else
      code = `<script setup>
${imports.join("\n")}
</script>
${code}`;
    const injectA = code.indexOf("<template>") + "<template>".length;
    const injectB = code.lastIndexOf("</template>");
    let body = code.slice(injectA, injectB).trim();
    if (body.startsWith("<div>") && body.endsWith("</div>"))
      body = body.slice(5, -6);
    code = `${code.slice(0, injectA)}
${getValaxyMain(body)}
${code.slice(injectB)}`;
    return code;
  };
}

// node/plugins/markdown/transform/page-data.ts
import path10 from "pathe";
function getHeadMetaContent(head, name) {
  if (!head || !head.length)
    return void 0;
  const meta = head.find(([tag, attrs = {}]) => {
    return tag === "meta" && attrs.name === name && attrs.content;
  });
  return meta && meta[1].content;
}
function inferDescription(frontmatter) {
  const { description, head } = frontmatter;
  if (description !== void 0)
    return description;
  return head && getHeadMetaContent(head, "description") || "";
}
async function generatePageData(code, id, options) {
  const fileInfo = Valaxy.state.idMap.get(id);
  const relativePath = path10.relative(options.userRoot, id);
  const fm = JSON.parse(JSON.stringify(fileInfo?.frontmatter));
  const pageData = {
    title: fm.title || fileInfo?.title || "",
    titleTemplate: fm.titleTemplate,
    description: inferDescription(fm),
    frontmatter: fm,
    // not be used
    headers: fileInfo?.headers || [],
    relativePath,
    filePath: id
  };
  pageData.lastUpdated = await getGitTimestamp(id);
  return pageData;
}

// node/plugins/markdown/markdownToVue.ts
var debug2 = _debug2("valaxy:md");
var cache2 = new LRUCache({ max: 128 });
function generateSlots() {
  const slots = [
    "main-header",
    "main-header-after",
    "main-nav",
    "main-content-before",
    "main-content",
    "main-content-after",
    "main-nav-before",
    "main-nav-after",
    "comment",
    "footer",
    "aside",
    "aside-custom"
  ];
  const slotsText = slots.map((s) => `<template #${s}><slot name="${s}" /></template>`).join("");
  return slotsText;
}
function getValaxyMain(mainContentMd) {
  const pageComponent = "ValaxyMain";
  return `
<${pageComponent} :frontmatter="$frontmatter">
  <template #main-content-md>${mainContentMd}</template>
  ${generateSlots()}
  <slot />
</${pageComponent}>
`;
}
async function createMarkdownToVueRenderFn(options, _viteConfig) {
  options.pages = options.pages.map((p) => p.replace(/\.md$/, "").replace(/\/index$/, ""));
  const transformCodeBlock = createTransformCodeBlock(options);
  const transformMarkdown = createTransformMarkdown(options);
  const transformEncrypt = createTransformEncrypt(options);
  const scanDeadLinks = createScanDeadLinks(options);
  const srcDir = options.userRoot;
  const isBuild = options.mode === "build";
  return async (code, id) => {
    const file = id;
    const relativePath = path11.relative(srcDir, file);
    const deadLinks = scanDeadLinks(code, id);
    const cacheKey = JSON.stringify({ code, id });
    if (isBuild) {
      const cacheKey2 = JSON.stringify({ code, id });
      const cached = cache2.get(cacheKey2);
      if (cached) {
        debug2(`[cache hit] ${relativePath}`);
        return cached;
      }
    }
    const start = Date.now();
    const pageData = await generatePageData(code, id, options);
    code = transformHexoTags(code, id);
    const data = resolveTransformIncludes(code, id, options);
    const includes = data.includes;
    code = data.code;
    code = transformCodeBlock(code, id);
    code = await transformEncrypt(code, id, pageData);
    code = transformFootnoteTooltip(code, id);
    code = transformMarkdown(code, id, pageData);
    debug2(`[render] ${file} in ${Date.now() - start}ms.`);
    const result = {
      code,
      pageData,
      deadLinks,
      includes
    };
    if (isBuild)
      cache2.set(cacheKey, result);
    Valaxy.state.idMap.delete(id);
    return result;
  };
}

// node/plugins/valaxy/index.ts
var nullVue = 'import { defineComponent } from "vue"; export default defineComponent({ render: () => null });';
function generateAppVue(root) {
  const appVue = join7(root, "App.vue");
  if (!fs19.existsSync(appVue))
    return nullVue;
  const scripts = [
    `import AppVue from "${toAtFS(appVue)}"`,
    "export default AppVue"
  ];
  return scripts.join("\n");
}
async function createValaxyPlugin(options, serverOptions = {}) {
  let { config: valaxyConfig } = options;
  const valaxyPrefix2 = "/@valaxy";
  let hasDeadLinks = false;
  let markdownToVue;
  let viteConfig;
  return [
    {
      name: "valaxy:loader",
      enforce: "pre",
      async configResolved(resolvedConfig) {
        viteConfig = resolvedConfig;
        markdownToVue = await createMarkdownToVueRenderFn(
          options,
          viteConfig
        );
      },
      configureServer(server) {
        if (options.configFile) {
          server.watcher.add(options.configFile);
        }
        server.watcher.add([
          options.clientRoot,
          options.themeRoot,
          options.userRoot
        ]);
      },
      resolveId(id) {
        if (id.startsWith(valaxyPrefix2))
          return id;
        return null;
      },
      async load(id) {
        const template = templates.find((t) => t.id === id);
        if (template) {
          return {
            code: await template.getContent.call(this, options),
            map: { mappings: "" }
          };
        }
        if (id === "/@valaxyjs/context") {
          return `export default ${JSON.stringify(JSON.stringify({
            userRoot: options.userRoot
            // clientRoot: options.clientRoot,
          }))}`;
        }
        if (id === "/@valaxyjs/AppVue")
          return generateAppVue(options.clientRoot);
        if (id === "/@valaxyjs/UserAppVue")
          return generateAppVue(options.userRoot);
        if (id === "/@valaxyjs/ThemeAppVue")
          return generateAppVue(options.themeRoot);
        if (id.startsWith(valaxyPrefix2)) {
          return {
            code: "",
            map: { mappings: "" }
          };
        }
      },
      async transform(code, id) {
        if (id.endsWith(".md")) {
          const { code: newCode, deadLinks, includes } = await markdownToVue(code, id);
          if (deadLinks.length) {
            hasDeadLinks = true;
            consola12.error(`Dead links found in ${id}`);
            consola12.error(deadLinks);
          }
          if (includes.length) {
            includes.forEach((i) => {
              this.addWatchFile(i);
            });
          }
          return newCode;
        }
      },
      renderStart() {
        if (hasDeadLinks && !(valaxyConfig.ignoreDeadLinks || valaxyConfig.build.ignoreDeadLinks))
          throw new Error("One or more pages contain dead links.");
      },
      /**
       * handle config hmr
       * @param ctx
       */
      async handleHotUpdate(ctx) {
        const { file, server, read } = ctx;
        const reloadConfigAndEntries = (config) => {
          serverOptions.onConfigReload?.(config, options.config);
          Object.assign(options.config, config);
          valaxyConfig = config;
          const moduleIds = ["/@valaxyjs/config", "/@valaxyjs/context"];
          const moduleEntries = [
            ...Array.from(moduleIds).map((id) => server.moduleGraph.getModuleById(id))
          ].filter((item) => !!item);
          return moduleEntries;
        };
        const configFiles = [options.configFile];
        if (configFiles.includes(file)) {
          const { config } = await resolveOptions({ userRoot: options.userRoot });
          return reloadConfigAndEntries(config);
        }
        if (file === options.siteConfigFile) {
          const { siteConfig } = await resolveSiteConfig(options.userRoot);
          valaxyConfig.siteConfig = replaceArrMerge(siteConfig, defaultSiteConfig);
          return reloadConfigAndEntries(valaxyConfig);
        }
        if (file === options.themeConfigFile) {
          const { themeConfig } = await resolveUserThemeConfig(options);
          const pkg = valaxyConfig.themeConfig.pkg;
          themeConfig.pkg = pkg;
          valaxyConfig.themeConfig = themeConfig;
          return reloadConfigAndEntries(valaxyConfig);
        }
        if (file === resolve10(options.themeRoot, "valaxy.config.ts")) {
          const themeValaxyConfig = await resolveThemeValaxyConfig(options);
          const valaxyConfig2 = mergeValaxyConfig(options.config, themeValaxyConfig);
          const { config } = await processValaxyOptions(options, valaxyConfig2);
          return reloadConfigAndEntries(config);
        }
        if (file.endsWith(".md")) {
          const endCount = countPerformanceTime();
          const content = await read();
          const { code, pageData } = await markdownToVue(content, file);
          const path17 = `/${relative(`${options.userRoot}/pages`, file)}`;
          const payload = {
            path: path17,
            pageData
          };
          server.hot.send({
            type: "custom",
            event: "valaxy:pageData",
            data: payload
          });
          vLogger.success(`${colors11.yellow("[HMR]")} ${file} ${colors11.dim(`updated in ${endCount()}`)}`);
          ctx.read = () => code;
        }
      }
    }
    // {
    //   // we need post encrypt html
    //   name: 'valaxy:encrypt:post',
    //   enforce: 'pre',
    //   async transform(code, id) {
    //     if (id.endsWith('.md'))
    //       code = await transformEncrypt(code, id)
    //     return code
    //   },
    // },
  ];
}

// node/plugins/vueRouter.ts
import fs20 from "fs-extra";
import matter3 from "gray-matter";
import { convert } from "html-to-text";
import { MarkdownItAsync } from "markdown-it-async";
import { resolve as resolve11 } from "pathe";
import VueRouter from "unplugin-vue-router/vite";

// node/plugins/presets/statistics.ts
import { existsSync as existsSync3, readFileSync } from "node:fs";
function count(content) {
  const cn = (content.match(/[\u4E00-\u9FA5]/g) || []).length;
  const en = (content.replace(/[\u4E00-\u9FA5]/g, "").match(/[\w\u0392-\u03C9\u0400-\u04FF]+|[\u4E00-\u9FFF\u3400-\u4DBF\uF900-\uFAFF\u3040-\u309F\uAC00-\uD7AF\u0400-\u04FF]+|[\u00E4\u00C4\u00E5\u00C5\u00F6\u00D6]+/g) || []).length;
  return {
    cn,
    en
  };
}
function readTime({ cn, en }, options) {
  const readingTime = cn / (options.speed.cn || 300) + en / (options.speed.en || 100);
  return readingTime < 1 ? 1 : Math.ceil(readingTime);
}
function wordCount({ cn, en }) {
  const num = cn + en;
  if (num < 1e3)
    return num.toString();
  return `${Math.round(num / 100) / 10}k`;
}
function statistics(content, options) {
  const countData = count(content);
  return {
    countData,
    wordCount: wordCount(countData),
    readingTime: readTime(countData, options.readTime)
  };
}
function presetStatistics({
  route,
  options
}) {
  const absolutePath = route.components.get("default") || "";
  if (existsSync3(absolutePath)) {
    const file = readFileSync(absolutePath, "utf-8");
    const { wordCount: wordCount2, readingTime } = statistics(file, {
      readTime: Object.assign({
        speed: {
          cn: 300,
          en: 100
        }
      }, options.readTime)
    });
    if (route.meta.frontmatter) {
      if (!route.meta.frontmatter.wordCount)
        route.meta.frontmatter.wordCount = wordCount2;
      if (!route.meta.frontmatter.readingTime)
        route.meta.frontmatter.readingTime = readingTime;
    }
  }
}

// node/plugins/vueRouter.ts
function getExcerptByType(excerpt = "", type = "html", mdIt) {
  switch (type) {
    case "ai":
    case "md":
      return excerpt;
    case "html":
      return mdIt.render(excerpt);
    case "text":
      return convert(mdIt.render(excerpt));
    default:
      return excerpt;
  }
}
async function createRouterPlugin(valaxyApp) {
  const { options } = valaxyApp;
  const { roots, config: valaxyConfig } = options;
  const mdIt = new MarkdownItAsync({ html: true });
  await setupMarkdownPlugins(mdIt, options);
  return VueRouter({
    extensions: [".vue", ".md"],
    routesFolder: roots.map((root) => `${root}/pages`),
    dts: resolve11(options.tempDir, "typed-router.d.ts"),
    ...valaxyConfig.router,
    /**
     * @experimental See https://github.com/posva/unplugin-vue-router/issues/43
     * we need get frontmatter before route, so write it in extendRoute
     */
    async extendRoute(route) {
      const defaultFrontmatter = JSON.parse(JSON.stringify(valaxyConfig.siteConfig.frontmatter)) || {};
      if (route.meta && route.meta.frontmatter) {
        const { frontmatter: _, otherMeta } = route.meta;
        route.meta = otherMeta;
      }
      route.addToMeta({
        frontmatter: defaultFrontmatter
      });
      if (route.fullPath === "/" || route.fullPath === "/page") {
        route.addToMeta({
          layout: "home"
        });
      }
      if (["/posts", "/posts/"].includes(route.fullPath)) {
        route.addToMeta({
          layout: "posts"
        });
      } else if (route.fullPath.startsWith("/posts/")) {
        if (route.children.length === 0) {
          route.addToMeta({
            layout: "post"
          });
        }
      }
      const path17 = route.components.get("default") || "";
      if (path17.endsWith(".md")) {
        const md3 = fs20.readFileSync(path17, "utf-8");
        const { data, excerpt, content } = matter3(md3, matterOptions);
        const mdFm = data;
        const lastUpdated = options.config.siteConfig.lastUpdated;
        delete mdFm.password;
        if (mdFm.gallery_password) {
          delete mdFm.gallery_password;
          delete mdFm.photos;
        }
        if (!mdFm.date)
          mdFm.date = (await fs20.stat(path17)).mtime;
        if (lastUpdated) {
          if (!mdFm.updated)
            mdFm.updated = (await fs20.stat(path17)).ctime;
        }
        if (mdFm.from) {
          if (Array.isArray(mdFm.from)) {
            mdFm.from.forEach((from) => {
              options.redirects.push({
                from,
                to: route.fullPath
              });
            });
          } else {
            options.redirects.push({
              from: mdFm.from,
              to: route.fullPath
            });
          }
        }
        const excludeKeys = [
          "albums",
          "excerpt",
          "girls",
          "links",
          "photos"
          // @TODO defineBasicLoader for page
          // 'projects',
        ];
        const routerFM = {
          ...mdFm,
          // 
          // @TODO 
          tags: typeof mdFm.tags === "string" ? [mdFm.tags] : mdFm.tags
        };
        excludeKeys.forEach((key) => {
          delete routerFM[key];
        });
        route.addToMeta({
          frontmatter: routerFM,
          excerpt: mdFm.excerpt || (excerpt ? getExcerptByType(excerpt, mdFm.excerpt_type || defaultFrontmatter.excerpt_type, mdIt) : "")
        });
        if (data.layout) {
          route.addToMeta({
            layout: data.layout
          });
        }
        if (!route.meta.frontmatter?.updated)
          route.meta.frontmatter.updated = mdFm.date;
        if (valaxyConfig.siteConfig.statistics.enable) {
          presetStatistics({
            options: valaxyConfig.siteConfig.statistics,
            route
          });
        }
        const ctx = {
          route,
          data,
          excerpt,
          content,
          path: path17
        };
        valaxyConfig.extendMd?.(ctx);
      }
      await valaxyApp.hooks.callHook("vue-router:extendRoute", route);
      return valaxyConfig.router?.extendRoute?.(route);
    },
    async beforeWriteFiles(root) {
      await valaxyApp.hooks.callHook("vue-router:beforeWriteFiles", root);
    }
  });
}

// node/plugins/preset.ts
async function ViteValaxyPlugins(valaxyApp, serverOptions = {}) {
  const { options } = valaxyApp;
  const { roots, config: valaxyConfig } = options;
  const MarkdownPlugin = await createMarkdownPlugin(options);
  const ValaxyPlugin = await createValaxyPlugin(options, serverOptions);
  const componentsDirs = roots.map((root) => `${root}/components`).concat(["src/components", "components"]);
  const vuePlugin = await import("@vitejs/plugin-vue").then(
    (r) => r.default({
      include: /\.(?:vue|md)$/,
      exclude: [],
      ...valaxyConfig.vue,
      template: {
        ...valaxyConfig.vue?.template,
        compilerOptions: {
          ...valaxyConfig.vue?.template?.compilerOptions,
          isCustomElement: (tag) => {
            let is = customElements.has(tag);
            valaxyConfig.vue?.isCustomElement?.forEach((fn) => {
              is = is || fn(tag);
            });
            return is;
          }
        }
      }
    })
  );
  const plugins = [
    MarkdownPlugin,
    ValaxyPlugin,
    vuePlugin,
    createConfigPlugin(options),
    createClientSetupPlugin(options),
    UnheadVite(),
    // https://github.com/posva/unplugin-vue-router
    await createRouterPlugin(valaxyApp),
    // https://github.com/JohnCampionJr/vite-plugin-vue-layouts
    Layouts({
      layoutsDirs: roots.map((root) => `${root}/layouts`),
      ...valaxyConfig.layouts
    }),
    // https://github.com/antfu/unplugin-vue-components
    Components({
      extensions: ["vue", "md"],
      // allow auto import and register components used in markdown
      include: [/\.vue$/, /\.vue\?vue/, /\.md$/],
      /**
       *  components/.exclude
       * `/[\\/]node_modules[\\/]/, `  node_modules/valaxy/client/components 
       */
      exclude: [/[\\/]\.git[\\/]/, /[\\/]\.exclude[\\/]/],
      // allow override
      allowOverrides: true,
      /**
       * override: user -> theme -> client
       *
       * latter override former
       */
      dirs: componentsDirs,
      dts: resolve12(options.tempDir, "components.d.ts"),
      ...valaxyConfig.components
    }),
    // https://github.com/antfu/unocss
    // UnocssPlugin,
    await createUnocssPlugin(options),
    // ...MarkdownPlugin,
    // https://github.com/intlify/bundle-tools/tree/main/packages/unplugin-vue-i18n
    VueI18n({
      runtimeOnly: true,
      compositionOnly: true,
      fullInstall: true,
      include: roots.map((root) => `${root}/locales/**`)
    }),
    createFixPlugins(options)
  ];
  if (valaxyConfig.groupIcons) {
    const { groupIconVitePlugin } = await import("vitepress-plugin-group-icons");
    plugins.push(
      groupIconVitePlugin({
        customIcon: {
          nodejs: "vscode-icons:file-type-node",
          playwright: "vscode-icons:file-type-playwright",
          typedoc: "vscode-icons:file-type-typedoc",
          eslint: "vscode-icons:file-type-eslint"
        },
        ...valaxyConfig.groupIcons
      })
    );
  } else {
    const virtualCssId = "virtual:group-icons.css";
    const resolvedVirtualCssId = `\0${virtualCssId}`;
    plugins.push({
      name: "valaxy:virtual:group-icons.css",
      resolveId(id) {
        if (id === virtualCssId) {
          return resolvedVirtualCssId;
        }
        return void 0;
      },
      async load(id) {
        if (id === resolvedVirtualCssId) {
          return "";
        }
        return void 0;
      }
    });
  }
  if (valaxyConfig.visualizer) {
    try {
      const visualizer = (await import("rollup-plugin-visualizer")).visualizer;
      plugins.push(
        visualizer({
          open: true,
          gzipSize: true,
          ...valaxyConfig.visualizer
        })
      );
    } catch (e) {
      console.error(e);
      consola13.error("Failed to load rollup-plugin-visualizer");
      consola13.error("Please install `rollup-plugin-visualizer` to enable the feature");
      console.log();
      consola13.info("pnpm add -D rollup-plugin-visualizer");
      console.log();
    }
  }
  return plugins;
}

// node/build.ts
async function build2(valaxyApp, viteConfig = defaultViteConfig) {
  const inlineConfig = mergeViteConfig2(viteConfig, {
    ...defaultViteConfig,
    plugins: await ViteValaxyPlugins(valaxyApp)
  });
  await viteBuild(inlineConfig);
}
async function ssgBuild(valaxyApp, viteConfig = {}) {
  const { options } = valaxyApp;
  const defaultConfig = {
    ...defaultViteConfig,
    plugins: await ViteValaxyPlugins(valaxyApp),
    ssr: {
      // TODO: workaround until they support native ESM
      noExternal: ["workbox-window", /vue-i18n/, "@vue/devtools-api"]
    }
  };
  defaultConfig.ssgOptions = {
    script: "async",
    formatting: "minify",
    beastiesOptions: {
      preload: "swap",
      // reduceInlineStyles: false,
      ...options.config.beastiesOptions || {}
    },
    onFinished() {
      generateSitemap(
        {
          hostname: options.config.siteConfig.url
        }
      );
    }
    // dirStyle default it flat
    // dirStyle: 'nested',
  };
  if (options.config.build.ssgForPagination) {
    defaultConfig.ssgOptions.includedRoutes = (paths, _routes) => {
      const newPaths = paths;
      const posts = paths.filter((path17) => path17.startsWith("/posts/"));
      const pageNumber = Math.ceil(posts.length / options.config.siteConfig.pageSize);
      consola14.info(`Generate ${colors12.yellow(pageNumber)} pages for pagination.`);
      for (let i = 1; i <= pageNumber; i++)
        newPaths.push(`/page/${i}`);
      if (!options.config.vite?.ssgOptions?.includeAllRoutes)
        return newPaths.filter((path17) => !path17.split("/").some((p) => p.startsWith(":")));
      else
        return newPaths;
    };
  }
  const inlineConfig = mergeViteConfig2(defaultConfig, viteConfig);
  await viteSsgBuild({}, inlineConfig);
}
async function postProcessForSSG(options) {
  const { userRoot: userRoot2 } = options;
  const indexPath = resolve13(userRoot2, "dist/index.html");
  if (fs21.existsSync(indexPath)) {
    consola14.info("post process for ssg...");
    const indexFile = await fs21.readFile(indexPath, "utf-8");
    const htmlTag = "</html>";
    if (!indexFile.endsWith(htmlTag)) {
      consola14.warn("fix incomplete index.html...");
      const htmlTagStart = indexFile.lastIndexOf(htmlTag);
      await fs21.writeFile(indexPath, indexFile.slice(0, htmlTagStart + htmlTag.length), "utf-8");
    }
  }
  if (!options.config.siteConfig.redirects?.useVueRouter)
    await generateClientRedirects(options);
}
async function generateClientRedirects(options) {
  consola14.info("generate client redirects...");
  const outputPath = resolve13(options.userRoot, "dist");
  const redirectRules = collectRedirects(options.redirects);
  const task = redirectRules.map(async (rule) => {
    const fromPath = join8(outputPath, `${rule.from}.html`);
    const toPath = join8(outputPath, `${rule.to}.html`);
    const routeExist = await fs21.pathExists(toPath);
    if (!routeExist)
      throw new Error(`the route of '${rule.to}' not exists`);
    await writeRedirectFiles(rule.to, fromPath);
  });
  await Promise.all(task);
}

// node/server.ts
import process7 from "node:process";
import { colors as colors13 } from "consola/utils";
import { createServer as createViteServer, mergeConfig as mergeViteConfig3 } from "vite";
function getServerInfoText(msg) {
  return `${valaxyPrefix} ${colors13.gray(msg)}`;
}
async function createServer(valaxyApp, viteConfig = {}, serverOptions = {}) {
  process7.env.EDITOR = process7.env.EDITOR || "code";
  const { options } = valaxyApp;
  const plugins = await ViteValaxyPlugins(valaxyApp, serverOptions);
  const enableDevtools = options.config.devtools;
  const vitePlugins = [
    ...plugins
  ];
  if (enableDevtools) {
    vitePlugins.push(
      (await import("vite-plugin-vue-devtools")).default(),
      (await import("@valaxyjs/devtools")).default({
        userRoot: options.userRoot
      })
    );
  }
  const mergedViteConfig = mergeViteConfig3(
    viteConfig,
    {
      plugins: vitePlugins
    }
  );
  const server = await createViteServer(mergedViteConfig);
  return server;
}

// node/cli/utils/cli.ts
import os from "node:os";
import path12 from "node:path";
import process8 from "node:process";
import { consola as consola15 } from "consola";
import { colors as colors14 } from "consola/utils";
import ora4 from "ora";
import { mergeConfig as mergeConfig3 } from "vite";

// node/env.ts
var GLOBAL_STATE = {
  valaxyApp: void 0,
  server: void 0
};

// node/cli/utils/cli.ts
function printInfo(options, port, remote) {
  const themeVersion = colors14.blue(`v${options.config.themeConfig?.pkg?.version}`) || "unknown";
  console.log();
  console.log(`  ${colors14.bold("\u{1F30C} Valaxy")}  ${colors14.blue(`v${version}`)}`);
  console.log();
  console.log(`${colors14.dim("  \u{1FA90} theme  ")} > ${options.theme ? colors14.green(options.theme) : colors14.gray("none")} (${themeVersion})`);
  console.log(`  ${colors14.dim("\u{1F4C1}")} ${colors14.dim(path12.resolve(options.userRoot))}`);
  if (port) {
    console.log();
    console.log(`${colors14.dim("  Preview   ")} > ${colors14.cyan(`http://localhost:${colors14.bold(port)}/`)}`);
    if (remote) {
      Object.values(os.networkInterfaces()).forEach(
        (v) => (v || []).filter((details) => details.family === "IPv4" && !details.address.includes("127.0.0.1")).forEach(({ address }) => {
          console.log(`${colors14.dim("  Network   ")} > ${colors14.blue(`http://${address}:${colors14.bold(port)}/`)}`);
        })
      );
    }
    console.log();
    const restart = `${colors14.underline("r")}${colors14.dim("estart")}`;
    const edit = `${colors14.underline("e")}${colors14.dim("dit")}`;
    const open = `${colors14.underline("o")}${colors14.dim("pen")}`;
    const qr = `${colors14.underline("q")}${colors14.dim("r")}`;
    const divider = `${colors14.dim(" | ")}`;
    console.log(`${colors14.dim("  shortcuts ")} > ${restart}${divider}${open}${divider}${qr}${divider}${edit}`);
  }
  console.log();
}
var serverSpinner = ora4(`${valaxyPrefix} creating server ...`);
async function initServer(valaxyApp, viteConfig) {
  disposeMdItInstance();
  disposePreviewMdItInstance();
  if (GLOBAL_STATE.server) {
    vLogger.info("close server...");
    await GLOBAL_STATE.server.close();
  }
  const { options } = valaxyApp;
  serverSpinner.start();
  const viteConfigs = mergeConfig3(
    await mergeViteConfigs(options, "serve"),
    viteConfig
  );
  try {
    GLOBAL_STATE.server = await createServer(valaxyApp, viteConfigs, {
      async onConfigReload(newConfig, config, force = false) {
        if (force) {
          vLogger.info(`${colors14.yellow("force")} reload the server`);
          initServer(valaxyApp, viteConfig);
        }
        let reload = false;
        if (newConfig.theme !== config.theme)
          reload = true;
        if (reload)
          initServer(valaxyApp, viteConfig);
      }
    });
    const server = GLOBAL_STATE.server;
    await server.listen();
    serverSpinner.succeed(`${valaxyPrefix} ${colors14.green("server ready.")}`);
    return server;
  } catch (e) {
    consola15.error("failed to start server. error:\n");
    console.error(e);
    process8.exit(1);
  }
}
if (import.meta.hot) {
  await import.meta.hot.data.stopping;
  let reload = async () => {
    consola15.info("HMR: Stop Server");
    await GLOBAL_STATE.server?.close();
  };
  import.meta.hot.on("vite:beforeFullReload", () => {
    const stopping = reload();
    reload = () => Promise.resolve();
    if (import.meta.hot)
      import.meta.hot.data.stopping = stopping;
  });
}

// node/cli/build.ts
async function execBuild({ ssg, root, output, log }) {
  setEnvProd();
  if (!isPagesDirExist(root))
    process9.exit(0);
  const userRoot2 = path13.resolve(root);
  const options = await resolveOptions({ userRoot: userRoot2 }, "build");
  setTimezone(options.config.siteConfig.timezone);
  printInfo(options);
  const valaxyApp = createValaxyNode(options);
  await callHookWithLog("options:resolved", valaxyApp);
  const modules2 = [];
  if (options.config.siteConfig.search.type === "fuse")
    modules2.push(fuseModule);
  if (options.config.modules.rss.enable)
    modules2.push(rssModule);
  setupModules(
    valaxyApp,
    modules2
  );
  const valaxyViteConfig = mergeConfig4(await mergeViteConfigs(options, "build"), options.config.vite || {});
  const viteConfig = mergeConfig4(
    valaxyViteConfig,
    {
      // avoid load userRoot/vite.config.ts repeatedly
      configFile: path13.resolve(options.clientRoot, "vite.config.ts"),
      build: {
        // make out dir empty, https://vitejs.dev/config/#build-emptyoutdir
        emptyOutDir: true,
        outDir: path13.resolve(options.userRoot, output)
      },
      logLevel: log
    }
  );
  await callHookWithLog("config:init", valaxyApp);
  await callHookWithLog("build:before", valaxyApp);
  consola16.box("\u{1F320} Start building...");
  try {
    if (ssg) {
      consola16.info(`use ${colors15.yellow("vite-ssg")} to do ssg build...`);
      try {
        await ssgBuild(valaxyApp, viteConfig);
        await postProcessForSSG(options);
      } catch (e) {
        consola16.error("[vite-ssg] An internal error occurred.");
        console.log(e);
      }
    } else {
      consola16.info("use vite do spa build...");
      await build2(valaxyApp, viteConfig);
    }
  } catch (e) {
    console.log(e);
  } finally {
    await callHookWithLog("build:after", valaxyApp);
  }
}
function registerBuildCommand(cli2) {
  cli2.command(
    "build [root]",
    "build your blog to static content",
    (args) => commonOptions(args).option("ssg", {
      alias: "s",
      type: "boolean",
      // https://github.com/antfu/vite-ssg/pull/219
      // to be true, when vite-ssg export build
      default: false,
      describe: "static site generate"
    }).option("output", {
      alias: "o",
      type: "string",
      default: "dist",
      describe: "output dir"
    }).option("log", {
      default: "warn",
      type: "string",
      choices: ["error", "warn", "info", "silent"],
      describe: "log level"
    }).strict().help(),
    async ({ ssg, root, output, log }) => {
      await execBuild({ ssg, root, output, log });
    }
  );
}

// node/cli/clean.ts
import path14 from "node:path";
import process10 from "node:process";
import { consola as consola17 } from "consola";
import fs22 from "fs-extra";

// node/cli/utils/fs.ts
import { access } from "node:fs/promises";
async function exists(path17) {
  try {
    await access(path17);
    return true;
  } catch (e) {
    return false;
  }
}

// node/cli/clean.ts
async function cleanDist() {
  const distDir = path14.join(process10.cwd(), "dist");
  const cacheDir = path14.join(process10.cwd(), ".valaxy");
  consola17.box("\u{1F9F9} Starting clean...");
  if (await exists(distDir)) {
    consola17.info("dist directory exists, removing...");
    try {
      await fs22.rm(distDir, { recursive: true, force: true });
      consola17.success("dist directory has been successfully removed.");
    } catch (error) {
      consola17.error("Failed to remove dist directory.");
      consola17.error(error);
    }
  } else {
    consola17.info("No dist directory found, nothing to clean.");
  }
  if (await exists(cacheDir)) {
    consola17.info(".valaxy cache directory exists, removing...");
    try {
      await fs22.rm(cacheDir, { recursive: true, force: true });
      consola17.success(".valaxy cache directory has been successfully removed.");
    } catch (error) {
      consola17.error("Failed to remove .valaxy cache directory.");
      consola17.error(error);
    }
  } else {
    consola17.info("No .valaxy cache directory found, nothing to clean.");
  }
}
function registerCleanCommand(cli2) {
  cli2.command(
    "clean",
    "Clean the dist folder and cache",
    () => {
    },
    async () => {
      await cleanDist();
    }
  );
}

// node/cli/debug.ts
import { consola as consola18 } from "consola";
function registerDebugCommand(cli2) {
  cli2.command("debug", "Debug your blog", async () => {
    consola18.info("\u63D0\u95EE\u524D\u8BF7\u643A\u5E26\u4EE5\u4E0B\u4FE1\u606F\uFF1A");
  });
}

// node/cli/deploy.ts
import process11 from "node:process";
import { confirm, intro, outro, select } from "@clack/prompts";
function registerDeployCommand(cli2) {
  cli2.command("deploy", "deploy your blog to the cloud", async () => {
    intro("Deploying Your Blog");
    const shouldBuild = await confirm({
      message: "Do you want to build your blog before deploying?"
    });
    if (shouldBuild) {
      await execBuild({ ssg: true, root: process11.cwd(), output: "dist", log: "info" });
    }
    const deployType = await select({
      message: "Where do you want to deploy?",
      options: [
        { label: "GitHub Pages", value: "gh-pages", hint: "You need install `gh-pages` dependencies." },
        { label: "Your Own Server", value: "server" }
      ]
    });
    if (deployType === "gh-pages") {
      let isGhPagesInstalled = false;
      try {
        await import("gh-pages");
        isGhPagesInstalled = true;
      } catch (e) {
        console.error(e);
        const installGhPages = await confirm({
          message: "Do you want to install `gh-pages` now?"
        });
        if (installGhPages) {
          await import("@antfu/install-pkg").then((i) => i.installPackage("gh-pages", { dev: true }));
          isGhPagesInstalled = true;
        } else {
          outro("Please install `gh-pages` before deploying to GitHub Pages.");
        }
      }
      if (isGhPagesInstalled) {
        const { publish } = await import("gh-pages");
        await publish("dist", {
          branch: "gh-pages",
          message: "chore: deploy by valaxy"
        });
        outro("Done!");
      }
    }
  });
}

// node/cli/dev.ts
import path15 from "node:path";
import process13 from "node:process";
import { mergeConfig as mergeConfig5 } from "vite";

// node/utils/net.ts
import net from "node:net";
async function findFreePort(start) {
  if (await isPortFree(start))
    return start;
  return await findFreePort(start + 1);
}
function isPortFree(port) {
  return new Promise((resolve15) => {
    const server = net.createServer((socket) => {
      socket.write("Echo server\r\n");
      socket.pipe(socket);
    });
    server.listen(port, "0.0.0.0");
    server.on("error", () => {
      resolve15(false);
    });
    server.on("listening", () => {
      server.close();
      resolve15(true);
    });
  });
}

// node/cli/utils/shortcuts.ts
import { exec } from "node:child_process";
import os2 from "node:os";
import process12 from "node:process";
import * as readline from "node:readline";
import { colors as colors16 } from "consola/utils";
import qrcode from "qrcode";
var SHORTCUTS = [
  {
    key: "r",
    description: "restart",
    async action(server, createDevServer) {
      await server.close();
      setTimeout(async () => {
        await createDevServer();
      }, 100);
    }
  },
  {
    key: "o",
    description: "open",
    async action(server) {
      const { default: openBrowser } = await import("open");
      openBrowser(`http://localhost:${server.config.server.port}/`);
    }
  },
  {
    key: "q",
    description: "qr",
    action(server) {
      const addresses = Object.values(os2.networkInterfaces()).flat().filter((details) => details?.family === "IPv4" && !details.address.includes("127.0.0.1"));
      const port = server.config.server.port;
      const remoteUrl = `http://${addresses[0]?.address || "localhost"}:${port}`;
      qrcode.toString(remoteUrl, { type: "terminal" }, (err, qrCode) => {
        if (err)
          throw err;
        console.log(qrCode);
      });
    }
  },
  {
    key: "e",
    description: "edit",
    action() {
      exec(`code "${process12.cwd()}"`, (err) => {
        if (err)
          console.error("Failed to open editor", err);
      });
    }
  }
];
function bindShortcuts(server, createDevServer) {
  if (!server.httpServer || process12.env.CI) {
    console.log("restart server to enable shortcuts", server.httpServer, process12.stdin.isTTY, process12.env.CI);
    return;
  }
  process12.stdin.resume();
  process12.stdin.setEncoding("utf8");
  readline.emitKeypressEvents(process12.stdin);
  if (process12.stdin.isTTY)
    process12.stdin.setRawMode(true);
  async function onKeyPress(str, key) {
    if (key.ctrl && key.name === "c") {
      process12.exit();
    } else {
      const shortcut = SHORTCUTS.find((shortcut2) => shortcut2.key === str);
      if (!shortcut)
        return;
      try {
        await shortcut.action(server, createDevServer);
      } catch (error) {
        console.error(colors16.red("Error executing shortcut:"), key, error);
      }
    }
  }
  process12.stdin.on("keypress", onKeyPress);
  server.httpServer.on("close", () => {
    process12.stdin.off("keypress", onKeyPress);
  });
}

// node/cli/dev.ts
async function startValaxyDev({
  root = process13.cwd(),
  port,
  remote,
  log,
  open
}) {
  setEnv();
  if (!isPagesDirExist(root))
    process13.exit(0);
  port = port || await findFreePort(4859);
  const resolvedOptions = await resolveOptions({ userRoot: root });
  setTimezone(resolvedOptions.config.siteConfig.timezone);
  const valaxyApp = createValaxyNode(resolvedOptions);
  GLOBAL_STATE.valaxyApp = valaxyApp;
  const viteConfig = mergeConfig5({
    // initial vite config
    ...defaultViteConfig,
    // avoid load userRoot/vite.config.ts repeatedly
    configFile: path15.resolve(resolvedOptions.clientRoot, "vite.config.ts"),
    server: {
      watch: {
        // watch theme updated
        ignored: [`!${resolvedOptions.themeRoot}/**`, `${resolvedOptions.userRoot}/**.md`]
      },
      port,
      strictPort: true,
      open,
      host: remote ? "0.0.0.0" : "localhost"
    },
    logLevel: log
  }, resolvedOptions.config.vite || {});
  const server = await initServer(valaxyApp, viteConfig);
  printInfo(resolvedOptions, port, remote);
  return server;
}
function registerDevCommand(cli2) {
  cli2.command(
    "* [root]",
    "Start a local server for Valaxy",
    (args) => commonOptions(args).option("port", {
      alias: "p",
      type: "number",
      describe: "port"
    }).option("open", {
      alias: "o",
      default: false,
      type: "boolean",
      describe: "open in browser"
    }).option("remote", {
      default: true,
      type: "boolean",
      describe: "listen public host and enable remote control"
    }).option("log", {
      default: "info",
      type: "string",
      choices: ["error", "warn", "info", "silent"],
      describe: "log level"
    }).strict().help(),
    async ({ root, port, open, remote, log }) => {
      let server;
      const createDevServer = async () => {
        server = await startValaxyDev({
          root,
          open,
          port,
          remote,
          log
        });
        bindShortcuts(server, createDevServer);
      };
      createDevServer();
    }
  );
}

// node/cli/utils/post.ts
import { writeFile as writeFile2 } from "node:fs/promises";
import { join as join9, resolve as resolve14 } from "node:path";
import { ensureSuffix as ensureSuffix2 } from "@antfu/utils";
import { consola as consola19 } from "consola";
import { colors as colors17 } from "consola/utils";
import dayjs2 from "dayjs";
import { render } from "ejs";

// node/cli/utils/constants.ts
import process14 from "node:process";
var userRoot = process14.cwd();
var defaultPostTemplate = `---
layout: <%=layout%>
title: <%=title%>
date: <%=date%>
---
`;

// node/cli/utils/scaffold.ts
import { readFile as readFile2 } from "node:fs/promises";
import path16 from "node:path";
async function getTemplate(layout) {
  const { clientRoot, themeRoot } = await resolveOptions({ userRoot });
  const roots = [userRoot, themeRoot, clientRoot];
  for (const root of roots) {
    const scaffoldPath = path16.resolve(root, "scaffolds", `${layout}.md`);
    if (await exists(scaffoldPath))
      return readFile2(scaffoldPath, "utf-8");
  }
  return false;
}

// node/cli/utils/post.ts
async function create(data) {
  const pagesPath = resolve14(userRoot, "pages");
  const {
    path: path17,
    title
  } = data;
  const postPath = path17 || join9("posts", title);
  let counter = 0;
  while (true) {
    let destinationPath = resolve14(pagesPath, postPath);
    if (counter)
      destinationPath = `${destinationPath}-${counter}`;
    destinationPath = ensureSuffix2(".md", destinationPath);
    if (!await exists(destinationPath)) {
      const content = await genLayoutTemplate(data);
      try {
        await writeFile2(destinationPath, content, "utf-8");
        consola19.success(`[valaxy new]: successfully generated file ${colors17.magenta(destinationPath)}`);
      } catch (e) {
        console.log(e);
        consola19.error(`[valaxy new]: failed to write file ${destinationPath}`);
        consola19.warn(`You should run ${colors17.green("valaxy new")} in your valaxy project root directory.`);
      }
      return destinationPath;
    }
    counter++;
  }
}
async function genLayoutTemplate({
  date,
  title,
  layout = "post"
}) {
  let template = await getTemplate(layout);
  if (!template)
    template = defaultPostTemplate;
  const dateFormat = "YYYY-MM-DD HH:mm:ss";
  return render(template, { title, layout, date: date ? dayjs2().format(dateFormat) : "" });
}

// node/cli/new.ts
function registerNewCommand(cli2) {
  cli2.command(
    "new <title>",
    "Draft a new post",
    (args) => {
      args.usage("$0 <title> -p [path] -l [layout]").positional("title", {
        describe: "The title of the new post",
        required: true
      }).option("path", {
        alias: "p",
        type: "string",
        describe: "the path to generate new post. Customize the path of post to generate"
      }).option("layout", {
        alias: "l",
        type: "string",
        default: "post"
      }).option("date", {
        alias: "d",
        type: "boolean",
        default: true,
        describe: "Generate post with the current date"
      }).strict().help();
    },
    async ({ title, path: path17, date, layout }) => {
      await create({
        title,
        date,
        layout,
        path: path17
      });
    }
  );
}

// node/cli/index.ts
var cli = yargs(hideBin(process15.argv)).scriptName("valaxy").usage("$0 [args]").version(version).showHelpOnFail(false).alias("h", "help").alias("v", "version");
registerDevCommand(cli);
registerBuildCommand(cli);
registerNewCommand(cli);
registerCleanCommand(cli);
registerDeployCommand(cli);
registerDebugCommand(cli);
cli.help();
var modules = [
  fuseModule,
  rssModule
];
modules.forEach((module) => {
  module.extendCli?.(cli);
});
function run() {
  cli.parse();
}

export {
  EXCERPT_SEPARATOR,
  EXTERNAL_URL_RE,
  PATHNAME_PROTOCOL_RE,
  ALL_ROUTE,
  customElements,
  defaultViteConfig,
  getGitTimestamp,
  isExternal,
  isPath,
  transformObject,
  isInstalledGlobally,
  resolveImportUrl,
  toAtFS,
  resolveImportPath,
  mergeViteConfigs,
  getIndexHtml,
  loadConfig,
  loadConfigFromFile,
  defaultSiteConfig,
  defineSiteConfig,
  resolveSiteConfigFromRoot,
  resolveSiteConfig,
  defaultValaxyConfig,
  defineValaxyConfig,
  defineConfig,
  resolveValaxyConfigFromRoot,
  mergeValaxyConfig,
  resolveValaxyConfig,
  defineValaxyAddon,
  defineAddon,
  resolveAddonsConfig,
  resolveThemeConfigFromRoot,
  resolveUserThemeConfig,
  defineValaxyTheme,
  defineTheme,
  defineUnoSetup,
  processValaxyOptions,
  resolveOptions,
  resolveThemeValaxyConfig,
  createValaxyPlugin,
  ViteValaxyPlugins,
  build2 as build,
  ssgBuild,
  postProcessForSSG,
  generateClientRedirects,
  getServerInfoText,
  createServer,
  startValaxyDev,
  registerDevCommand,
  cli,
  run
};
/*! Bundled license information:

@mdit-vue/shared/dist/index.mjs:
@mdit-vue/plugin-sfc/dist/index.mjs:
  (* istanbul ignore if -- @preserve *)
*/
